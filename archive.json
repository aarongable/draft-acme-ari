{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-10-03T01:20:38.768125+00:00",
  "repo": "aarongable/draft-acme-ari",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOGGBRNc48nnmt",
      "title": "Consider disallowing POST-as-GET for renewalInfo",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/3",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The renewalInfo objects are going to be queried very frequently, and their data is highly cacheable. The draft should take a stronger stance and disallow POST-as-GET entirely.\r\n\r\nThis was suggested during the [ACME WG interim meeting](https://datatracker.ietf.org/meeting/interim-2021-acme-01/materials/minutes-interim-2021-acme-01-202109291400-00), but I forget by which participant.",
      "createdAt": "2021-10-05T23:06:45Z",
      "updatedAt": "2021-10-26T23:54:47Z",
      "closedAt": "2021-10-26T23:54:47Z",
      "comments": [
        {
          "author": "jcjones",
          "authorAssociation": "NONE",
          "body": "Yes, this will be necessary for adoption.",
          "createdAt": "2021-10-05T23:07:08Z",
          "updatedAt": "2021-10-05T23:07:08Z"
        },
        {
          "author": "jcjones",
          "authorAssociation": "NONE",
          "body": "Specifically, we wouldn't be able to roll this out unless it can be cached. The database load for also verifying an account signature on each renewal check -- which could be even more often than OCSP checks -- would be very difficult to manage without significant architecture changes. ",
          "createdAt": "2021-10-06T00:16:52Z",
          "updatedAt": "2021-10-06T00:16:52Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOGGBRNc48nrH0",
      "title": "Make renewalInfo URLs third-party constructable",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/4",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As suggested by @agwa (Andrew Ayer) [on the mailing list](https://mailarchive.ietf.org/arch/msg/acme/L-vaZbikL8rq5v5g3Aa-vqCA6uM/) and [in the WG interim meeting](https://datatracker.ietf.org/meeting/interim-2021-acme-01/materials/minutes-interim-2021-acme-01-202109291400-00), it would be useful for the renewalInfo URLs to be obtainable by means other than just being embedded in Order objects.\r\n\r\nOptions include:\r\n- put the renewalInfo url in the cert itself\r\n- put a base url in the directory, then combine that with a path slug derived from the cert itself\r\n\r\nThe former doesn't really work because there's not an available extension to use. We could define a new one, but I expect pushback against adding ~50 bytes to every cert that isn't useful to the vast majority of clients.\r\n\r\nThe latter has a few sub-options as well:\r\n- compute the slug as the fingerprint (sha-1 hash) of the whole cert\r\n- compute the slug similar to OCSP: issuer name hash, issuer pubkey hash, cert serial\r\n\r\nWe should figure out the best way to represent this, then modify the draft accordingly.",
      "createdAt": "2021-10-05T23:17:42Z",
      "updatedAt": "2021-10-26T23:55:20Z",
      "closedAt": "2021-10-26T23:55:20Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOGGBRNc48w9Fp",
      "title": "Cleanups: use backticks everywhere appropriate",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/6",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "They get turned into nice fixed-width sections in the HTML output, and don't clutter up the plaintext output at all.",
      "createdAt": "2021-10-06T23:43:38Z",
      "updatedAt": "2021-11-05T21:30:42Z",
      "closedAt": "2021-11-05T21:30:42Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOGGBRNc48w9HP",
      "title": "Show Retry-After header in example response",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/7",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-06T23:43:54Z",
      "updatedAt": "2021-11-05T21:30:42Z",
      "closedAt": "2021-11-05T21:30:42Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOGGBRNc49cR1N",
      "title": "How often to retry in the face of errors",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/8",
      "state": "CLOSED",
      "author": "jsha",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We should specify a little more about how hard clients should retry when they are inside the suggested window, and when the suggested window is in the past. Right now we say \"If the selected time is in the past, the client SHOULD attempt renewal immediately.\" But I can see that leading to implementations that retry really aggressively regardless of failures.\r\nWhat we want is more like: \"If the selected time is in the past, the client SHOULD consider the certificate eligible for immediate renewal, subject to the client's existing error backoffs and retry intervals.\"",
      "createdAt": "2021-10-19T23:22:53Z",
      "updatedAt": "2021-11-08T23:35:03Z",
      "closedAt": "2021-11-08T23:35:02Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOGGBRNc49yXvU",
      "title": "Clarify client and server behavior around malformed renewalInfo stanzas",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/9",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- Is the time period inclusive of the \"end\" timestamp?\r\n- What happens if one of the timestamps is missing or malformed?\r\n- What happens if the client gets no response at all?",
      "createdAt": "2021-10-26T18:31:02Z",
      "updatedAt": "2021-11-08T23:59:01Z",
      "closedAt": "2021-11-08T23:59:01Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOGGBRNc49zOVx",
      "title": "Add draft-only section for Current Implementations",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/10",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Other drafts I've seen have sections pointing at current implementations, which get removed by the editor before leaving draft state. Let's add one pointing at the new implementation in Boulder.",
      "createdAt": "2021-10-26T23:56:55Z",
      "updatedAt": "2021-11-08T23:26:13Z",
      "closedAt": "2021-11-08T23:26:13Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOGGBRNc4-dpfR",
      "title": "Encourage clients to retry as often as possible",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/13",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The semantics of the `Retry-After` header only give us half of what we want: it delays clients, but doesn't also tell them to retry as soon after that period is over as they can. We should come up with a mechanism (a polling period in the directory? as its own key, as part of the renewalInfo key, or as part of the meta object? or maybe directly in the renewalInfo response object instead?) to more clearly communicate when we suggest that a client recheck the renewalInfo.",
      "createdAt": "2021-11-08T21:55:54Z",
      "updatedAt": "2024-02-08T01:09:26Z",
      "closedAt": "2024-02-08T01:09:26Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOGGBRNc4-dtqb",
      "title": "Consider a \"This has been renewed\" endpoint",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/15",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "One of the use-cases for ARI is being able to inform clients that they should renew ASAP, because the CA intends to revoke their certificate in the near future and would like to help the client avoid a service interruption.\r\n\r\nIn this case, it would be helpful for the CA to know when a client considers a cert to have been renewed (which may involve several newOrder and Finalize requests, in the case of validation/issuance failures, or certs with many identifiers having those identifiers shuffled between them) so that the cert can be safely revoked.\r\n\r\nSketch:\r\n```\r\nPOST /acme/renewal-info/<issuer-key-hash>/<issuer-name-hash>/<serial> HTTP/1.1\r\nHost: example.com\r\nContent-Type: application/jose+json\r\n\r\n{\r\n  \"protected\": base64url({\r\n    \"alg\": \"ES256\",\r\n    \"jwk\": {...},\r\n    \"nonce\": \"6S8IqOGY7eL2lsGoTZYifg\",\r\n    \"url\": \"https://example.com/acme/renewal-info/<issuer-key-hash>/<issuer-name-hash>/<serial>\"\r\n  }),\r\n  \"payload\": base64url({\r\n    \"renewed\": true,\r\n  }),\r\n  \"signature\": \"RZPOnYoPs1PhjszF...-nh6X1qtOFPB519I\"\r\n}\r\n```",
      "createdAt": "2021-11-08T22:16:43Z",
      "updatedAt": "2022-03-30T15:12:17Z",
      "closedAt": "2022-03-30T15:12:16Z",
      "comments": [
        {
          "author": "jesperkristensen",
          "authorAssociation": "NONE",
          "body": "This seems similar to if the client revokes the certificate with reason code \"superseded\" using the existing ACME endpoint. So why is a new endpoint needed?\r\n\r\nArguments against always revoking may be that the certificate could be still in use by the time the ACME client thinks renewal is complete, because of eventual consistency. Or because the certificate may be later restored from a backup. But those concerns would apply to this new renewed endpoint as well.\r\n\r\nI guess the new endpoint allows the CA more flexibility in choosing when to revoke based on a risk vs. reward trade-off.\r\n\r\nWould Let's Encrypt consider not sending renewal reminder emails for certificates that are marked as renewed using this API?",
          "createdAt": "2021-11-13T07:55:42Z",
          "updatedAt": "2021-11-13T07:55:42Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Ooh that's a really good point; I'd forgotten about the \"superseded\" reason code. That may be all that's necessary here -- it is the same number of total requests to the ACME server, accomplishes the goal of revocation, and provides a clear indication of why revocation happened. It *is* less flexible than the new API proposed above, which would allow a CA to decide when and whether to revoke. But honestly maybe encouraging the whole ecosystem to move to \"renew then revoke\" in all circumstances is a good thing.\r\n\r\nI think concerns about eventual consistency are valid. In particular, there may be clients which are concerned about exactly that, and so choose to never revoke the recently-replaced cert. And that model would be fine in most circumstances... until a mass revocation event happens and the CA doesn't know when it is \"okay\" to revoke the old cert.\r\n\r\nYes, today LE has to decide whether or not to send a renewal reminder based on a very rough heuristic. If confirmation of renewal existed -- either in the form of the proposed new API call, or in the form of the old cert being revoked as superseded -- that heuristic could be greatly improved.",
          "createdAt": "2021-11-15T16:20:56Z",
          "updatedAt": "2021-11-15T16:20:56Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOGGBRNc4-pg9u",
      "title": "Include justification of sha1 in Security Considerations",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/16",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The choice to mandate sha1 for the issuer name hash and issuer key hash is based on rfc5019 \"Lightweight OCSP Profile\" and the fact that the purpose of the hash is non-cryptographic. Include a sentence or two with this same info in the security considerations section.",
      "createdAt": "2021-11-11T15:02:01Z",
      "updatedAt": "2022-03-18T18:10:57Z",
      "closedAt": "2022-03-18T18:10:56Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Closing this because we're moving away from SHA1 (see #17)",
          "createdAt": "2022-03-18T18:10:56Z",
          "updatedAt": "2022-03-18T18:10:56Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOGGBRNc4-pldP",
      "title": "Consider `base64url(CertID)` for url slug",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/17",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently, renewalInfo URLs are constructed as\r\n```\r\n[directory base path] / hex(sha1(issuer name)) / hex(sha1(issuer key)) / hex(serial)\r\n```\r\n\r\nThis mandates SHA1, which on the one hand is in-line with RFC5019 \"Lightweight OCSP Profile\", but on the other hand mandates an out-of-date hashing algorithm.\r\n\r\nThis could instead be formulated as\r\n```\r\n[directory base path] / base64url(CertID)\r\n```\r\nwhere `CertID` is the ASN.1 Sequence specified in RFC6960\r\n```\r\n   CertID          ::=     SEQUENCE {\r\n       hashAlgorithm       AlgorithmIdentifier,\r\n       issuerNameHash      OCTET STRING, -- Hash of issuer's DN\r\n       issuerKeyHash       OCTET STRING, -- Hash of issuer's public key\r\n       serialNumber        CertificateSerialNumber }\r\n```\r\n\r\nThis would allow different ACME servers to set different policies around what hash algorithms they accept, and would allow some amount of agility around hash algorithms in the future. On the other hand, it would make requests relatively opaque (can't tell from the URL alone what issuer is being requested, due to the base64url encoding), it would make requests larger (due to the ans.1 and encoding overhead), and it would directly couple this spec to OCSP instead of just borrowing its ideas.",
      "createdAt": "2021-11-11T15:19:50Z",
      "updatedAt": "2022-03-29T20:53:13Z",
      "closedAt": "2022-03-29T20:53:13Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOGGBRNc5CxRNZ",
      "title": "URL Construction is Under-Specified",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/18",
      "state": "CLOSED",
      "author": "AGWA",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The full request URL is computed by concatenating the `renewalInfo` URL from the server's directory with the following case-insensitive hex-encoded (see [@!RFC4648], Section [@!RFC4648, section 8]) elements, separated by forward slashes:\r\n>\r\n> * the SHA-1 hash of the issuer's public key (often included in the certificate as the Authority Key Identifier, see [@!RFC5280], Section [@!RFC5280, section 4.2.1.1]),\r\n\r\nIs this hash computed over the DER encoding of the SubjectPublicKeyInfo (as in HPKP and CRLSets), just the public key minus tag and length (as in OCSP), or something else?\r\n\r\nIf the goal is to mimic OCSP, then I would recommend using the same language as RFC 6960, which is clear: \"issuerKeyHash is the hash of the issuer's public key.  The hash shall be calculated over the value (excluding tag and length) of the subject public key field in the issuer's certificate.\"\r\n\r\nI strongly recommend dropping the reference to AKI.  There is no requirement for AKI to be computed this way, and referencing it may lead some implementers to construct the URL from the AKI extension instead of from the issuer certificate, which may be easier but is definitely not correct.\r\n\r\n> * the SHA-1 hash of the issuer's Distinguished Name, see [@!RFC5280], Section [@!RFC5280, section 4.1.2.4], and\r\n\r\nIs this hash computed over the DER encoding?  Should it come from the certificate's issuer field, or the issuer's subject field (which may not be byte-for-byte identical)?  Again, I would recommend using RFC 6960's language: \"The hash shall be calculated over the DER encoding of the issuer's name field in the certificate being checked.\"\r\n\r\n> * the certificate serial number.\r\n\r\nEncoded how? I see the example is uppercase hex, but this leaves two possibilities:\r\n\r\n1. It's a hex encoding of the integer.  This means there may be an odd number of hexits.  Are negative serial numbers  prefixed with an ASCII minus sign?  Is it OK to have leading zeros, or must it be the shortest possible representation of the integer?\r\n2. It's a hex encoding of the bytes in the DER encoding. This means there are always an even number of hexits, negative serial numbers are in twos-compliment, and positive serial numbers whose most-significant-bit is one are padded with a zero byte.\r\n\r\nA major advantage to the scheme proposed in #17 is that it's inherently precise because it's just the DER encoding of an ASN.1 structure.  The current scheme is going to require a lot of words to be sufficiently precise, and even then I foresee implementation divergences (e.g. some CAs accepting leading zeros in the serial and others not) and bugs (e.g. clients not properly encoding negative serials, or serials with a leading one bit) which will make ARI less reliable.  With #17, clients can just leave the encoding to an ASN.1 library, possibly reusing existing, battle-tested code from OCSP implementations.",
      "createdAt": "2022-02-01T04:07:54Z",
      "updatedAt": "2022-03-29T20:53:13Z",
      "closedAt": "2022-03-29T20:53:13Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Yep, I essentially agree. I intend to at the very least clarify this phrasing, and much more likely go with the plan outlined in #17 with the additional restriction of disallowing SHA-1 (or maybe requiring SHA-256?) for the hash algorithm used in the CertID.",
          "createdAt": "2022-02-04T22:27:46Z",
          "updatedAt": "2022-02-04T22:27:46Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOGGBRNc5F0tFd",
      "title": "Motivation: place more emphasis on non-revocation use-cases",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/19",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Like smoothing out normal midnight-cron spikes.",
      "createdAt": "2022-03-16T19:10:24Z",
      "updatedAt": "2022-03-18T18:10:24Z",
      "closedAt": "2022-03-18T18:10:24Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "I forgot that I've actually already done this; the introduction doesn't mention revocation at all.",
          "createdAt": "2022-03-18T18:10:24Z",
          "updatedAt": "2022-03-18T18:10:24Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOGGBRNc5F0wEW",
      "title": "Consider adding caching guidance",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/20",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Similar to the caching language in the Lightweight OCSP RFC, adding it here explicitly will make it more obvious what the best practices are. Maybe even just a reference to an http caching rfc.",
      "createdAt": "2022-03-16T19:23:21Z",
      "updatedAt": "2022-07-21T23:55:18Z",
      "closedAt": "2022-07-21T23:55:18Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOGGBRNc5HhAJj",
      "title": "UPDATE addition",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/25",
      "state": "CLOSED",
      "author": "icing",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is there more information about the added benefit of updating renewal information in regards to the `renewed` flag?\r\n\r\nI am asking because this puts some burden on clients that, so far, did not have to track the state of \"old\" certificates. User, for now, are able to wipe their local certs and thus reset the ACME client in case they got stuck somewhere or just for purely forcing a renewal. This would make any action on the new state (or lack of) by the CA doubtful.\r\n\r\nAlso, there are scenarios where users switch from one CA to another, so clients would need to contact the previous CA on renewal somewhere else. Should that lead to errors, the client is stuck in the process between two ACME CAs somewhat. This would mean that there is a \"signoff\" procedure with retries and error reporting etc. \r\n\r\nIf this feature is regarded as purely optional, my estimation would be that support is a single-attempt best effort, if implemented at all. Given the complications described, I fail to imagine what a CA expects to accomplish. Thus my question.\r\n\r\nThanks for your time.",
      "createdAt": "2022-04-11T11:27:21Z",
      "updatedAt": "2023-08-10T20:13:25Z",
      "closedAt": "2023-08-10T20:13:25Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOGGBRNc5IKXm9",
      "title": "Query: Conforming clients MUST select a uniform random time within the suggested window",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/26",
      "state": "CLOSED",
      "author": "robplee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aarongable"
      ],
      "labels": [],
      "body": "Hi,\r\n\r\nApologies for joining slightly late to the party, however I only recently discovered the existence of this draft.  If this would be better sent as an email to the mailing list please let me know and I'll get that sent as soon as I'm able.\r\n\r\nI think strictness of the requirement for clients to choose a uniform random time within the suggested renewal window is a little strange.  Especially when considering that if the clients only check the ARI after the window has ended then the standard only states that they _should_ attempt to renew immediately.  Furthermore, if the renewal window is before the next time the client would check then _may_ attempt to renew immediately.  This seems an odd combination of key words to me.\r\n\r\nWould it not be more appropriate for the recommendation to choose a random time to be a \"SHOULD\" or even \"It is RECOMMENDED that conforming clients select a uniform random...\" rather than the \"MUST\" in the current text?\r\n\r\nIt seems to me that if this draft is to give means for the CA to provide \"suggestions on when [clients] should renew certificates\" then the language should be not quite so forceful and allow for users* to choose when in the window they request renewal, some users (especially if they are customers of a commercial CA) may prefer to aim for the end of the renewal window and get their money's worth out of their existing cert, meanwhile others might want to aim for the start of the window in order to maximise the time available to get their new certificate properly installed and everything configured properly.\r\n\r\n\r\n*I appreciate that in ACME we are assuming users are software clients but it seems to me that checking ARI could be integrated into a notification system that would tell a human to fire up their ACME client and get a new cert if they weren't willing to set everything up quite so automatically.",
      "createdAt": "2022-04-21T08:19:50Z",
      "updatedAt": "2023-04-02T16:48:25Z",
      "closedAt": "2022-07-22T17:26:08Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "You bring up an interesting point. The original idea when I was writing that paragraph was: \"fully specify _how_ to compute when to renew; then only provide suggestions for what to do with that information\". But maybe phrasing it as \"the client SHOULD renew at a time of its choosing within the window; the following algorithm for selecting a time is RECOMMENDED: ...\" would be best. I'll work on a change to that effect now.",
          "createdAt": "2022-07-21T22:50:56Z",
          "updatedAt": "2022-07-21T22:50:56Z"
        },
        {
          "author": "osirisinferi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Question about this if I may: the choice of words in #32 which addressed this issue leaves room for renewing *outside* of the window, as long as that renewal time was based on the window (where e.g. an hour before or after the window is also allowed). Was that also the intention of #32?",
          "createdAt": "2023-04-02T16:47:54Z",
          "updatedAt": "2023-04-02T16:48:25Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOGGBRNc5IKdED",
      "title": "Does the renewal-info URL need to use RFC6960 certIDs?",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/27",
      "state": "CLOSED",
      "author": "robplee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nAs in #26, I'm sorry for joining the part so late and do let me know if this discussion would be better placed on the mailing list.\r\n\r\nAs in the name of the issue: why are the renewal-info resource URLs using certIDs?  I appreciate that because POST-as-GET has been specifically banned to aid in caching then there is an argument for not using IDs that would have to be remembered or accessed via a POST-as-GET but I'm wondering if RFC6960 certIDs are just making life more difficult than it needs to be by introducing all the complexity of choosing which hash algorithms to support and then having to somehow communicate which ones those are.\r\n\r\nWould it not make life easier to just use the certificate serial number either hex or base64 URL encoded with trailing '='s removed?\r\n\r\nI appreciate that this seems to have already been the subject of discussion in #17 but I can't see much discussion there about if a serial number only solution was considered?",
      "createdAt": "2022-04-21T08:34:07Z",
      "updatedAt": "2022-05-02T20:42:47Z",
      "closedAt": "2022-05-02T20:42:46Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "It's a good question, but one that has already been addressed in prior discussion here, on the mailing list, and in IETF meetings.\r\n\r\nSerial numbers alone cannot be used because the serial uniqueness constraint (imposed by the Baseline Requirements) applies on a per-issuer basis, while the uniqueness of these URLs needs to apply on a per-ACME-server basis. An ACME server may issue certificates from many different intermediates, so cannot guarantee serial uniqueness across the whole server.\r\n\r\nGiven that we need to be able to unambiguously uniquely identify the end-entity certificate in question, re-using the scaffolding from OCSP (which the ecosystem has accepted as a sufficiently-unique ID) allows clients to also re-use code. This will make life less difficult in the long run, rather than more difficult.",
          "createdAt": "2022-05-02T20:42:46Z",
          "updatedAt": "2022-05-02T20:42:46Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOGGBRNc5IKgGt",
      "title": "Typos/wording suggestions",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/28",
      "state": "CLOSED",
      "author": "robplee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Super subjective here so feel free to dismiss any of these as simply being me declaring \"Well, I'd have written it this way.\"\r\n\r\nAbstract:\r\n\"an ACME server may provide **hints** to ACME clients\" -> \"an ACME server may provide **suggestions** to ACME clients\"\r\n\r\nIntroduction:\r\n\"validity period and proactive **smearing** of load\" -> \"validity period and proactive **distribution** of load\"\r\n\r\nGetting Renewal Information:\r\nNot quite sure of exactly what should be changed where but RFC 8555 explicitly states that the results of various endpoints is a JSON object and I'm wondering if it would be an improvement to make it clear that the renewalInfo resource is sent to the requesting client as a JSON object containing the suggestedWindow JSON object and optionally including the explanationURL?  I think that wording is a bit clumsy but I think it might be a good extra precision to add?\r\n\r\nHappy to open a PR for any and all changes considered worth doing.",
      "createdAt": "2022-04-21T08:44:53Z",
      "updatedAt": "2022-06-13T21:08:15Z",
      "closedAt": "2022-06-13T21:08:15Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Abstract: \"an ACME server may provide **hints** to ACME clients\" -> \"an ACME server may provide **suggestions** to ACME clients\"\r\n\r\nGreat, I love it\r\n\r\n> Introduction: \"validity period and proactive **smearing** of load\" -> \"validity period and proactive **distribution** of load\"\r\n\r\nYep, this is an improvement.\r\n\r\n> Getting Renewal Information: Not quite sure of exactly what should be changed where but RFC 8555 explicitly states that the results of various endpoints is a JSON object and I'm wondering if it would be an improvement to make it clear that the renewalInfo resource is sent to the requesting client as a JSON object containing the suggestedWindow JSON object and optionally including the explanationURL? I think that wording is a bit clumsy but I think it might be a good extra precision to add?\r\n\r\nI personally believe that the current language which directly copies the phrasing used in RFC8555 itself when defining each individual resource is sufficiently specific -- this document is essentially written to be read as though it were dropped wholesale into the middle of RFC8555 inline. But happy to accept suggestions!",
          "createdAt": "2022-05-02T20:45:49Z",
          "updatedAt": "2022-05-02T20:45:49Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Fixed by #29 ",
          "createdAt": "2022-06-13T21:08:15Z",
          "updatedAt": "2022-06-13T21:08:15Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOGGBRNc5LOqqr",
      "title": "signatureAlgorithm should be hashAlgorithm?",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/30",
      "state": "CLOSED",
      "author": "osirisinferi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[line 103](https://github.com/aarongable/draft-acme-ari/blob/6410fba49a018098afb6234c6e068ba4e5084153/draft-aaron-acme-ari.md?plain=1#L103) currently states:\r\n\r\n> (&hellip;) a DER-encoded `CertID` ASN.1 sequence [@!RFC6960, section 4.1.1].\r\n\r\nLooking at the `CertID` structure in RFC6960, section 4.1.1, it states:\r\n\r\n> CertID ::= SEQUENCE {\r\n>    hashAlgorithm           AlgorithmIdentifier,\r\n>    issuerNameHash          OCTET STRING, -- Hash of issuer's DN\r\n>    issuerKeyHash           OCTET STRING, -- Hash of issuer's public key\r\n>    serialNumber            CertificateSerialNumber }\r\n \r\nHowever, [line 114](https://github.com/aarongable/draft-acme-ari/blob/6410fba49a018098afb6234c6e068ba4e5084153/draft-aaron-acme-ari.md?plain=1#L114) of the draft states:\r\n\r\n> (&hellip;) if it receives a request whose embedded `signatureAlgorithm` field contains an unacceptable OID (&hellip;)\r\n\r\nThe `signatureAlgorithm` is part of the \"Signature\" sequence of RFC 6960, which doesn't seem to be used in this draft.",
      "createdAt": "2022-06-06T17:27:04Z",
      "updatedAt": "2022-06-13T21:07:41Z",
      "closedAt": "2022-06-13T21:07:41Z",
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDOGGBRNc5Q2EI4",
      "title": "Add zero duration windows to the malformed response example",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/36",
      "state": "CLOSED",
      "author": "beautifulentropy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-30T21:46:44Z",
      "updatedAt": "2023-02-08T22:39:57Z",
      "closedAt": "2023-02-08T22:39:57Z",
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOGGBRNc5kfCj6",
      "title": "Nit; small incongruence with quoting",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/40",
      "state": "CLOSED",
      "author": "beautifulentropy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**4.1**\r\n> Trailing \u2018=\u2019 characters MUST be stripped.\r\n\r\n**4.2**\r\n> with trailing \u201c=\u201d stripped\r\n\r\nI prefer the first one as it calls these out as characters (e.g. there could be multiple).",
      "createdAt": "2023-04-26T23:07:43Z",
      "updatedAt": "2024-02-08T17:19:42Z",
      "closedAt": "2024-02-08T17:19:42Z",
      "comments": []
    },
    {
      "number": 41,
      "id": "I_kwDOGGBRNc5pnSWm",
      "title": "Consider adding a \"batch\" endpoint, which returns ARI info for all certs under a single account",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/41",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This would allow clients which manage many certs to get all of the relevant info in a single request. As requested here: https://community.letsencrypt.org/t/thoughts-from-starting-to-play-with-ari/200276",
      "createdAt": "2023-06-23T18:30:45Z",
      "updatedAt": "2024-02-08T17:52:20Z",
      "closedAt": "2024-02-08T17:52:20Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "There's still not a version of this that I like. The suggestions in that thread and the [associated mailing list thread](https://mailarchive.ietf.org/arch/msg/acme/AeJ3zJKcBF-ZUhQXJajC0bb7orI/) are unworkable: complex mechanisms for listing all certs whose suggested windows have changed based on their issuance time or validation method are just a reinvention of CRLs. Simpler methods (e.g. a page-able per-account endpoint) may still be in the cards, but I haven't seen people really asking for those, I've just offered them as an alternative to other requests.",
          "createdAt": "2023-08-09T23:07:44Z",
          "updatedAt": "2023-08-09T23:07:44Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Given that we still haven't developed a version of this that we like, I'm going to close this out. I don't think it's worth it.",
          "createdAt": "2024-02-08T17:52:20Z",
          "updatedAt": "2024-02-08T17:52:20Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOGGBRNc5pnSnc",
      "title": "Consider including renewalInfo inside finalized Order objects",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/42",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This would allow a client to get the suggested renewal window immediately upon issuance, without having to follow up with an ARI query. As requested here: https://community.letsencrypt.org/t/thoughts-from-starting-to-play-with-ari/200276",
      "createdAt": "2023-06-23T18:31:27Z",
      "updatedAt": "2024-02-08T00:46:06Z",
      "closedAt": "2024-02-08T00:46:06Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Assuming https://github.com/aarongable/draft-acme-ari/pull/51 goes through, this becomes a bit easier, since we'll already be making other modifications to the Order object.",
          "createdAt": "2023-08-09T23:05:08Z",
          "updatedAt": "2023-08-09T23:05:08Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "For the time being, I've decided against doing this -- I believe it would encourage clients to schedule their next wake-up for a time  inside the initial suggested renewal window, thereby removing the ability for clients to detect changes in the suggested window. Instead, clients should be encouraged to begin polling ARI.",
          "createdAt": "2024-02-08T00:46:06Z",
          "updatedAt": "2024-02-08T00:46:06Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOGGBRNc5pnZ2u",
      "title": "Consider changing URL construction away from OCSP CertID",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/43",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Feedback from client authors (forum, email) is making it clear that using the OCSP CertID structure is not actually making client implementation easier. It comes with real benefits for sure: algorithm agility, uniquely identifying cert even across CAs, etc. But most libraries don't expose a way to easily access this structure (they produce fully OCSP requests instead), so authors are often copy-pasting segments of code from their language's crypto libraries.",
      "createdAt": "2023-06-23T18:53:31Z",
      "updatedAt": "2023-08-10T18:52:03Z",
      "closedAt": "2023-08-10T18:52:03Z",
      "comments": [
        {
          "author": "aaomidi",
          "authorAssociation": "NONE",
          "body": "Thanks for making this issue!\r\n\r\nI'm too new to the space to know the historical context of why OCSP is the way it is. But I think with ARI enough time has past to make the ecosystem of databases, etc be able to handle a different structure to query it.\r\n\r\nI'm wondering, since certificate fingerprints has been used for certificate identification in the past - are there any problems you foresee if ARI used that for the GET handling?\r\n",
          "createdAt": "2023-06-23T21:26:19Z",
          "updatedAt": "2023-06-23T21:26:19Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "One immediate disadvantage is that the lack of algorithm agility. In fact, the only IETF documents I've found (although I easily could have missed some) that define the concept of a \"certificate fingerprint\" use SHA-1 to do so! (https://datatracker.ietf.org/doc/html/rfc4572, https://datatracker.ietf.org/doc/html/rfc4387). If you scour stack overflow and forums you will find many people dying on the hill that \"fingerprint\" means SHA-1 and \"thumbprint\" means SHA-256, or that you're supposed to compute it over the PEM instead of the DER, or various other forms of confusion. I'd prefer not to perpetuate any of that.\r\n\r\nAnother disadvantage is opacity. With the OCSP CertId, you can inspect each part separately: do I recognize this serial? do I recognize this issuer hash? If you recognize some of the parts, you may be able to know what went wrong with the client's request (or your own database lookup!) and provide a good error message. If all you're handed is an opaque bytestring, you either recognize it or you don't and that's it.\r\n\r\nAnd selfishly, I think it is disadvantageous to define a new way to uniquely identify a cert when we already have a perfectly good way: hash algorithm, hash of issuer info, serial. I'm fine with coming up with some other way to convey that triplet of information, but I do find myself preferring that tuple over an opaque blob.",
          "createdAt": "2023-06-23T21:54:45Z",
          "updatedAt": "2023-06-23T21:54:45Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOGGBRNc5pn-8S",
      "title": "A couple alternatives to consider instead of a window",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/44",
      "state": "CLOSED",
      "author": "mholt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For reasons explained in this letter to the IETF WG:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/acme/AeJ3zJKcBF-ZUhQXJajC0bb7orI/\r\n\r\nI would like to explore some alternatives to the current draft. I can think\r\nof two approaches that might address those concerns:\r\n\r\nA) Instead of a totally separate flow to obtain ARI, simply utilize a\r\nRetry-After header in the flow of existing ACME responses. Upon finalizing\r\nan order, the ACME server can respond with a Retry-After header which acts\r\nas the current-draft Retry-After header for ARI responses. The client then\r\nattempts renewal at/after the Retry-After time, but with the OCSP CertID\r\nadded to the NewOrder object; this indicates to the ACME server that the\r\nclient is asking if now is a good time to renew the certificate indicated\r\nby the CertID. If it's not a good time, the ACME server can reply as such,\r\nwith another Retry-After, and the client then waits and repeats, until the\r\nserver actually issues the certificate. If the client needs the certificate\r\nimmediately, simply omit the CertID from the NewOrder and the normal,\r\n\"non-ARI\" flow is assumed. This is backwards-compatible and requires no\r\nadditional infrastructure or endpoints.\r\n\r\nB) If we do need a separate flow for some reason, I would like to see a\r\nsingle endpoint containing a static JSON resource that describes all the\r\nactive certificates that need early renewal, rather than one\r\ntediously-crafted URL per certificate. Certificates can be described by\r\ntheir NotBefore or NotAfter dates, serial numbers, or other relevant\r\nattributes. For example, if just a few certs with certain serials were\r\nmisissued, those serials could be enumerated at this endpoint. Or if a mass\r\nrevocation is happening, the timeframe of NotBefore dates could be listed,\r\nand ACME clients can simply check against the certs they manage with those\r\ndates, and replace them. You can represent millions of certificates in,\r\nlike, 85 bytes this way. And it's way less work for clients and servers.\r\nAnd lastly, drop the \"window\" idea -- certificates described by this\r\nendpoint should be renewed ASAP: try to renew immediately, then back off\r\nand retry, for reasons described above (once we know the future is\r\nuncertain and/or revocation is imminent, current certs can't be trusted\r\nand/or clients must try to preserve their sites' uptime).\r\n\r\n---\r\n\r\nSince you've probably heard most of the stuff in that letter already, I wanted to at least bring forth those two ideas for discussion here.\r\n\r\nThanks for your diligent work on ARI!",
      "createdAt": "2023-06-23T20:14:49Z",
      "updatedAt": "2024-05-03T22:09:40Z",
      "closedAt": "2024-05-03T22:09:40Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "On the LE forums, it was mentioned that it would be useful if the CA could know that a certificate has specifically been replaced by another, and to know which ones those are.\r\n\r\nProposal (A) above I think should be able to solve that.\r\n\r\nFrancis Lavoie, on our Slack, made a good point to me:\r\n\r\n> Something we see is sometimes Caddy replaces an LE cert with ZeroSSL\r\n\r\nSo if we end up using a different CA to replace the certificate, what do you think should happen?",
          "createdAt": "2023-06-23T20:51:15Z",
          "updatedAt": "2023-06-23T20:51:15Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "It looks like (A) has been partially implemented by adding the `Replaces` value into `NewOrder` flows, which I am pleased to see. I think that's an improvement. I still wouldn't mind consolidating the ARI flow into Order flows, but I understand this has been debated elsewhere already.\r\n\r\nI am also still partial to (B) -- or at least most of it -- instead of a per-certificate endpoint. I understand that makes things easier for servers but it makes things more complicated for clients and doesn't scale as well.",
          "createdAt": "2024-05-03T14:56:04Z",
          "updatedAt": "2024-05-03T14:56:04Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "(B) describes what I would consider three separate changes:\r\n- Offer a bulk endpoint;\r\n- Allow that bulk endpoint to _describe_ certs (such as by their notAfter), rather than uniquely identifying them; and\r\n- Have anything that shows up in the bulk endpoint be renewed immediately instead of given a window.\r\n\r\nI think that all three of these are not improvements to ARI. The first has already been extensively debated on mailing lists, and I won't reiterate the arguments here. The second means specifying (and implementing!) a whole collection of methods by which certificates could be grouped and those groups described, which I believe is not worthwhile and would make client implementation significantly more complex. The third does away with significant swathes of the utility of ARI, removing any ability of clients to plan ahead on short timescales.\r\n\r\nAbsent a suggested specification of exactly what this would look like and how it would be incorporated into the current ARI draft, I don't think it would be an improvement to accept these suggestions.",
          "createdAt": "2024-05-03T22:09:40Z",
          "updatedAt": "2024-05-03T22:09:40Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOGGBRNc5qMZ8i",
      "title": "Consider recommending clients log and audit \"immediate renewal\" scenarios as a best-practice",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/46",
      "state": "CLOSED",
      "author": "jvanasco",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consider a subsection under the \"Getting Renewal Information\" titled \"Immediate Renewal Scenarios\".  \r\n\r\nIt should explain some situations in which a \"renew now\" payload is sent, and a security audit or server configuration audit may be necessary.\r\n\r\nPossible text:\r\n\r\n```\r\n## Immediate Renewal Scenarios\r\n\r\nIf the `end` of the `suggestedWindow` is in the past, clients **SHOULD** attempt renewal immediately.\r\n\r\nInstances like this **SHOULD** be logged and investigated.  If the ARI payload contains an `explanationUrl`, it should be logged and reviewed.\r\n\r\nThere are three main scenarios that will cause a Certificate to require immediate renewal:\r\n\r\n* The Certificate has been revoked through the ACME API.  This is often due to an intended action of the Certificate's owner, but this can be due to the result of a malicious actor who obtains the credentials necessary for revocation.  \r\n* The Certificate has been revoked by the Certificate Authority in a mass revocation event.  This could be due to a minor violation of the CA/B Baseline Requirements or a significant security concern.\r\n* The client has failed to refresh ARI information on the recommended basis. This could be due to the client or a scheduler being incorrectly configured.\r\n\r\nThe above list is not exhaustive; other scenarios can require immediate renewal.  It is recommended that all immediate renewal situations are logged and audited.  In situations where there is a security concern, such as an unintended revocation, subscribers should ensure the revocation was an unintended consequence of their actions and not due to a security compromise.  Subscribers may decide to inspect Certificate Transparent Logs for the affected domains.  In situations where there may be a misconfiguration of the client or a scheduler, subscribers should audit their integrations to ensure future Certificates are renewed in a timely manner.\r\n```\r\n",
      "createdAt": "2023-06-29T23:38:00Z",
      "updatedAt": "2024-07-18T23:17:09Z",
      "closedAt": "2024-07-18T23:17:09Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "> If the `end` of the `suggestedWindow` is in the past, clients **SHOULD** attempt renewal immediately.\r\n\r\nIsn't that already implied in the spec? (Maybe it wasn't a year ago when this issue was posted.) The recommended algorithm is to renew if the selected date within the window is in the past, and if `end` is in the past, then necessarily any date in the window is in the past too.\r\n\r\nMy reading of the current draft suggests no additional text is needed.",
          "createdAt": "2024-05-03T14:54:26Z",
          "updatedAt": "2024-05-03T14:54:26Z"
        },
        {
          "author": "jvanasco",
          "authorAssociation": "NONE",
          "body": "No change to the algorithm is suggested by this.  That line could be updated to whatever the current \"Immediate Renewal\" (IR) language is.\r\n\r\nThe purpose of this Issue is to recommend the logging and investigation of all detected IRs \u2013 and explain that in most situations, an IR (as indicated by a past expiration time in the payload) is almost certainly because of a server misconfiguration or CA revocation.\r\n\r\nAFAIK, the only times a Subscriber should expect an IR are:\r\n* They revoked that certificate themselves\r\n* They have just onboarded ARI functionality for the first time\r\n\r\nUnless you're expecting an IR payload for those reasons, detecting one generally means that something, somewhere, has broken \u2013 so Clients should log and alert Subscribers to investigate.\r\n\r\nIMHO, aside from those two situations, the most likely causes of an IR are going to be (in descending order):\r\n\r\n* Server misconfiguration - ARI checks are not happening as they should.  \r\n* Mass revocation event - this may impact connectivity for end-users and other systems\r\n* A malicious actor has revoked their certificate\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-05-03T15:21:54Z",
          "updatedAt": "2024-05-03T15:21:54Z"
        },
        {
          "author": "petercooperjr",
          "authorAssociation": "NONE",
          "body": "I don't know if you might just call this \"Server misconfiguration\", but it might be good to consider cases where the server isn't up 24/7. For home appliance-type servers (like a network-attached storage device or whatnot), if I have it turned off for a week when I go on vacation, and then when I turn it back on it turns out that it missed its ARI window and needs to renew immediately, that really isn't a \"critical failure that needs to be investigated now\" scenario.\r\n\r\nI think the real indicator of something wonky requiring investigation might just be whether that explanationUrl is present. But there isn't much guidance to CAs on when to populate it, so I could imagine one CA always populating it with a link to their regular documentation about preferred renewal timelines, and another CA only populating it when initiated by a compliance incident. It might be worth having it be a \"SHOULD\" or \"RECOMMENDED\" or the like for that explanationUrl field to be populated if the certificate was revoked (or is about to be revoked), and maybe guidance that it shouldn't be populated for \"normal\" time windows.",
          "createdAt": "2024-05-16T20:27:23Z",
          "updatedAt": "2024-05-16T20:27:23Z"
        },
        {
          "author": "jvanasco",
          "authorAssociation": "NONE",
          "body": "A server with periodic connectivity is a specific case with a minority of users, and obviously/inherently not a misconfiguration.  We can easily generate a long list of other specific usages and edge cases that will affect 2%-20% of users - that should not prevent advising the majority of Subscribers that a missed ARI window is likely something that should be quickly looked at.",
          "createdAt": "2024-05-16T21:05:14Z",
          "updatedAt": "2024-05-16T21:05:14Z"
        },
        {
          "author": "petercooperjr",
          "authorAssociation": "NONE",
          "body": "Sure; not really objecting. I'm just not sure how much of this \"implementation guidance\" should be in the RFC, vs. some other place. (And I mean that \"not sure\" sincerely, this may be the best place for it.) And all I was trying to do is to ensure that the server with intermittent connectivity was thought of somewhere in the process, I know it's not the common use case.",
          "createdAt": "2024-05-16T21:09:21Z",
          "updatedAt": "2024-05-16T21:09:21Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "I think this is largely why I'm not in favor of adding language to this effect. There are many reasons for \"immediate renewal\" scenarios:\r\n- your cert has been or is about to be revoked\r\n- the CA has shifted your renewal window for load balancing purposes\r\n- the CA has randomly jittered your renewal window for agility purposes\r\n- your server was offline for an extended period\r\n- absolutely nothing is wrong, the randomly-selected time within the renewal window just happens to have fallen a few seconds ago\r\n\r\n\r\nAlso:\r\n\r\n> I could imagine one CA always populating [the explanationURL] with a link to their regular documentation about preferred renewal timelines\r\n\r\nLet's Encrypt plans to do exactly this, so I'm not a fan of saying CAs should avoid populating it",
          "createdAt": "2024-05-20T23:19:58Z",
          "updatedAt": "2024-05-20T23:19:58Z"
        },
        {
          "author": "petercooperjr",
          "authorAssociation": "NONE",
          "body": "Yeah, I think the thing that needs to be logged and investigated is if the certificate wasn't renewed before some percentage of its lifetime. Even if it renews really early because of some CA incident, there really isn't anything for the server owner to do in that case; everything went exactly as it should.\r\n\r\nWe regards to explanationURL, I guess I'm just not sure exactly what the client or administrator should really *do* with that information. I guess it could be helpful to be logged just in case the administrator is curious about why a certificate was renewed early, but again if the renewal is successful then I don't think there's any action they should really be taking. The scenario that might be more meaningful is when the suggested window is in the past *and renewal fails*, and in that case the administrator needs to be alerted because it may indicate a future problem (CA planned downtime or incident requiring revoking or whatnot) that they need to figure out how to work around (by ensuring that their system answering challenges is up, switching CAs, or whatever), and the explanationURL might help them understand the impact.",
          "createdAt": "2024-05-20T23:29:28Z",
          "updatedAt": "2024-05-20T23:29:28Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "> Yeah, I think the thing that needs to be logged and investigated is if the certificate wasn't renewed before some percentage of its lifetime.\r\n\r\nWe do this in Caddy/CertMagic... if it's the last 1/20th or 1/50th of its lifetime (there's two code paths - one for ARI, one without) we emit a slightly louder log saying that we're renewing now (in the ARI code path, we specifically mention that we're ignoring ARI at that point).\r\n\r\n> We regards to explanationURL, I guess I'm just not sure exactly what the client or administrator should really do with that information. I guess it could be helpful to be logged just in case the administrator is curious about why a certificate was renewed early, but again if the renewal is successful then I don't think there's any action they should really be taking. The scenario that might be more meaningful is when the suggested window is in the past and renewal fails, and in that case the administrator needs to be alerted because it may indicate a future problem (CA planned downtime or incident requiring revoking or whatnot) that they need to figure out how to work around (by ensuring that their system answering challenges is up, switching CAs, or whatever), and the explanationURL might help them understand the impact.\r\n\r\nYeah, we are just logging the explanationURL, and if there's a failure, you can go into the same logs that report the error, and find the explanationURL. :man_shrugging: ",
          "createdAt": "2024-05-20T23:35:25Z",
          "updatedAt": "2024-05-20T23:35:25Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOGGBRNc5t6WDa",
      "title": "Improve the IANA Considerations section",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/47",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "It should conform to the requirements at https://www.rfc-editor.org/rfc/rfc8126.html and the additional guidance at https://www.iana.org/help/protocol-registration.",
      "createdAt": "2023-08-09T21:03:40Z",
      "updatedAt": "2023-08-09T22:32:23Z",
      "closedAt": "2023-08-09T22:32:23Z",
      "comments": []
    },
    {
      "number": 50,
      "id": "I_kwDOGGBRNc5t6xl3",
      "title": "Replace POST updates with field in newOrder requests",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/50",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Instead of POSTing to the renewalInfo endpoint indicating that a certificate has been replaced, simply include the unique identifier of the previous certificate in the newOrder request. This has multiple advantages:\r\n- the client doesn't have to make additional requests, just the ones it would normally make\r\n- the CA knows which new order is a renewal, and whether that new order is taking place during the ARI suggested window\r\n- the CA can use this info to: bypass rate limits, revoke replaced certs during an incident, and track renewal rate metrics\r\n\r\nThis has one disadvantage:\r\n- notice of replacement happens at the same time as renewal, rather than sometime thereafter, meaning there may be a gap between when the replacement certificate has been issued and when it has been provisioned and is truly usable. But this gap is only relevant in one context (when the CA is conducting mass revocations), in which case the replaced cert is going to be revoked sooner or later anyway, and continuity of service is provided on a best-effort basis.",
      "createdAt": "2023-08-09T22:30:27Z",
      "updatedAt": "2023-08-10T20:13:25Z",
      "closedAt": "2023-08-10T20:13:25Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOGGBRNc509rgW",
      "title": "Serial number encoding ambiguity",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/52",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-ietf-acme-ari-02.html#section-4.1 refers to *\"the bytes of the certificate's Serial Number value\"*, and provides an example *\"certificate's Serial Number field\"* that is described as an *\"ASN.1 Integer value\"*.\r\n\r\nThe Summary in the ASN.1 specification ([X.680 02/2021](https://www.itu.int/rec/T-REC-X.680-202102-I/en)) says:\r\n*\"The ASN.1 notations can be applied whenever it is necessary to define the abstract syntax of information without constraining in any way how the information is encoded for transmission.\"*\r\n\r\nSince a certificate's signature is calculated over its DER encoding, I'm guessing that *\"the bytes of the certificate's\"* is intended to imply that it is the contents octets of the DER encoding of the ASN.1 INTEGER Serial Number field that should be used to produce the ARI request.  However, I think this should be stated explicitly, to avoid ambiguity.\r\n\r\nClarity on this point will be particularly important when dealing with Serial Numbers whose DER encoded contents octets begin with a 0x00 octet, which serves to indicate that the integer is non-negative. Such octets are part of the (two's complement) DER encoding of an ASN.1 INTEGER, but AIUI are not considered part of the abstract notation of an ASN.1 INTEGER.  (Consider, for [example](https://crt.sh/?id=3334561879), how `openssl x509 -text` displays serial numbers without these leading 0x00 contents octets).  If an ARI client omits the 0x00 but the ARI server is expecting the 0x00 (or vice versa), the ARI server will respond with an error.\r\n\r\nI think it would also be helpful to change the example serial number in section 4.1 to be one whose DER encoding requires a leading 0x00 contents octet.",
      "createdAt": "2023-10-25T22:11:00Z",
      "updatedAt": "2024-02-08T20:00:26Z",
      "closedAt": "2024-02-08T19:01:08Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Thanks for pointing this out! This is a really good point, and I've addressed it in the PR above. I'm going to merge that PR so I can publish the next version of this document, but definitely let me know if you see any issues with my updated phrasing or example. Thanks again!",
          "createdAt": "2024-02-08T19:01:08Z",
          "updatedAt": "2024-02-08T19:01:08Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @aarongable.  LGTM!",
          "createdAt": "2024-02-08T20:00:25Z",
          "updatedAt": "2024-02-08T20:00:25Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOGGBRNc5_Jm4i",
      "title": "Update endpoint",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/55",
      "state": "CLOSED",
      "author": "mholt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm updating [acmez](https://github.com/mholt/acmez) to conform with the [latest spec draft 3](https://www.ietf.org/archive/id/draft-ietf-acme-ari-03.html), and realized I didn't know how to update my `UpdateRenewalInfo()` function.\r\n\r\nI might have missed the reasons for the edits, but I noticed drafts 2 and 3 don't have a section 4.2 about updating renewal status anymore. Just wanted to ask about that.\r\n\r\nThe language in section 4.1 still says:\r\n\r\n> This new resource both allows clients to query the server for suggestions on when they should renew certificates, and allows clients to inform the server when they have completed renewal (or otherwise replaced the certificate to their satisfaction).\r\n\r\nPS. I like the changes to the renewal endpoint URI, much simpler!! I was able to delete about 100 lines of convoluted code.",
      "createdAt": "2024-02-13T22:25:27Z",
      "updatedAt": "2024-02-18T02:22:25Z",
      "closedAt": "2024-02-15T23:51:00Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "That's correct, the ability to POST to the renewalInfo endpoint to mark a certificate as replaced has been (ahem) replaced by the ability to mark a new-order request as replacing a previous certificate. This reduces the total number of requests in an issuance flow, and gives CAs much more context about that replacement, at the cost of some flexibility (e.g. indicating that a cert has been replaced via issuance from a different CA).\r\n\r\nThanks for noting the vestigial language in 4.1, I'll fix that.",
          "createdAt": "2024-02-15T23:47:24Z",
          "updatedAt": "2024-02-15T23:47:24Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Ah, gotcha. Thank you for bridging the gap in my understanding.\r\n\r\nI like that better.",
          "createdAt": "2024-02-18T02:22:16Z",
          "updatedAt": "2024-02-18T02:22:25Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOGGBRNc6AQ_VF",
      "title": "Return HTTP 409 \"Conflict\" when the certificate identified by 'replaces' has already been replaced",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/56",
      "state": "CLOSED",
      "author": "beautifulentropy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> The HTTP 409 Conflict response status code indicates a request conflict with the current state of the target resource.\r\n\r\nEven perfect record-keeping on the part of the client can be undermined by unexpected data and/or power loss. Providing an error code which indicates that the client should retry the renewal without the 'replaces' field would be helpful.\r\n\r\nCredit to @jsha for this idea.",
      "createdAt": "2024-02-23T23:12:51Z",
      "updatedAt": "2024-08-23T22:42:30Z",
      "closedAt": "2024-08-23T22:42:30Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "I like this idea. I think it'll take the form of massaging this paragraph:\r\n> Servers SHOULD check that the identified certificate and the current New Order request correspond to the same ACME Account and share identifiers, and that the identified certificate has not already been marked as replaced by a different finalized Order. Servers MAY ignore the replaces field in New Order requests which do not pass such checks.\r\n\r\nI think that middle clause should be broken into a separate sentence that says that already-replaced certificates SHOULD result in an HTTP 409. We should still say that other forms of invalid replaces fields (e.g. garbage bytes, certs issued by other CAs, certs issued by this CA but to a different account) can be handled however, per server policy.",
          "createdAt": "2024-02-26T20:09:33Z",
          "updatedAt": "2024-02-26T20:09:33Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Would getting a 409 just imply retrying without the Replaces field? I'm trying to figure out how to reconcile the clients record with the servers. How does the client know what cert it was replaced with already?",
          "createdAt": "2024-02-26T20:33:38Z",
          "updatedAt": "2024-02-26T20:33:38Z"
        },
        {
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would getting a 409 just imply retrying without the Replaces field? I'm trying to figure out how to reconcile the clients record with the servers. How does the client know what cert it was replaced with already?\r\n\r\nThe client should drop the 'replaces' field value and retry again. If a 409 is received that's the server indicating that this same ACME account has already completed another finalized order which indicated it was a replacement for this certificate.",
          "createdAt": "2024-02-26T22:02:19Z",
          "updatedAt": "2024-02-26T22:02:19Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Thanks. One last question, if two orders are concurrent with the same `replaces` value, does a 409 still get returned in that case?\r\n\r\n",
          "createdAt": "2024-02-26T22:11:21Z",
          "updatedAt": "2024-02-26T22:11:21Z"
        },
        {
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks. One last question, if two orders are concurrent with the same `replaces` value, does a 409 still get returned in that case?\r\n\r\nThanks for asking for this clarification. I'll have to amend what we've said above: \r\n\r\nThe CA should return a 409 when an existing replacement order is already Finalized, Pending, Ready, or Processing. If that order becomes Invalid, another replacement order can be made.",
          "createdAt": "2024-02-26T22:39:36Z",
          "updatedAt": "2024-02-26T22:40:47Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is indicating \"that the client should retry the renewal without the 'replaces' field\" the only use case for an HTTP 409 response?  If so, then I'm struggling to see why an HTTP 409 response would be more helpful than the -03 behaviour *\"Servers MAY ignore the `replaces` field in New Order requests which do not pass such checks\"*.\r\n\r\nIf a Server ignores the `replaces` field, then the Order object returned by the newOrder endpoint will omit the `replaces` field.  Isn't that enough of a signal to the Client that the Server has not treated the new order as a renewal?  (The -03 behaviour also avoids the Client having to retry the request, which seems preferable, all other things being equal).\r\n\r\nOr, are we envisaging that there might be reasons for a Client to choose to _not_ retry the renewal if an HTTP 409 is received?  If so, what reasons?",
          "createdAt": "2024-02-27T10:42:13Z",
          "updatedAt": "2024-02-27T10:42:13Z"
        },
        {
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is indicating \"that the client should retry the renewal without the 'replaces' field\" the only use case for an HTTP 409 response? If so, then I'm struggling to see why an HTTP 409 response would be more helpful than the -03 behaviour _\"Servers MAY ignore the `replaces` field in New Order requests which do not pass such checks\"_.\r\n> \r\n> If a Server ignores the `replaces` field, then the Order object returned by the newOrder endpoint will omit the `replaces` field. Isn't that enough of a signal to the Client that the Server has not treated the new order as a renewal? (The -03 behaviour also avoids the Client having to retry the request, which seems preferable, all other things being equal).\r\n> \r\n> Or, are we envisaging that there might be reasons for a Client to choose to _not_ retry the renewal if an HTTP 409 is received? If so, what reasons?\r\n\r\nThe sole use case for an HTTP 409 response is to handle situations where there's already a replacement order made by the same ACME account. This scenario typically suggests issues such as poor record-keeping by the client or potential data loss. Rejecting the request is a clear signal to the operator (and client author) that something is amiss.",
          "createdAt": "2024-02-27T15:45:28Z",
          "updatedAt": "2024-02-27T15:45:28Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "> Rejecting the request is a clear signal to the operator (and client author) that something is amiss.\r\n\r\nThat's all well and good, but I am left with the question as to what to do with this information (as a client). All we know is we need a cert. Server already has a record of it being replaced? Cool. We still need a cert. IMO \"replacing\" a cert should be idempotent, unless there's some obvious course of action I'm not considering... sure, we can retry without the \"replaces\" field, but, why? Like, I won't really be able to do anything about it on my end will I?",
          "createdAt": "2024-02-27T15:48:52Z",
          "updatedAt": "2024-02-27T15:48:52Z"
        },
        {
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's all well and good, but I am left with the question as to what to do with this information (as a client). All we know is we need a cert. Server already has a record of it being replaced? Cool. We still need a cert. IMO \"replacing\" a cert should be idempotent, unless there's some obvious course of action I'm not considering... sure, we can retry without the \"replaces\" field, but, why? Like, I won't really be able to do anything about it on my end will I?\r\n\r\nThank you for sharing your concerns. You're correct in noting that even if the server has a record of the certificate being replaced, as a client, you still require a valid certificate.\r\n\r\nThis update is primarily aimed at clients filing numerous concurrent certificate replacements due to flaws in their implementation. By notifying these clients when a replacement order has already been made, it serves as an alert to them that there might be an issue with their implementation. This is particularly relevant considering the rate limit exemptions that are granted for ARI-triggered orders.\r\n\r\nIf you're seeing these replacement notifications as a one-off, it might not significantly impact you. However, for clients experiencing frequent 409s, it's a crucial signal indicating that they're not fully performing proper record-keeping and thus are not benefitting from the rate limit exemptions. Simply removing the 'replaces' field and proceeding without acknowledging it could lead to incorrect implementations which are never fully identified.",
          "createdAt": "2024-02-27T17:56:31Z",
          "updatedAt": "2024-02-27T17:56:31Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Rejecting the request is a clear signal to the operator (and client author) that something is amiss.\r\n\r\n@beautifulentropy Are you implying that it would be a meaningfully less clear signal for the Server to instead accept the newOrder request and omit `replaces` in the returned Order object?  If so, please could you explain your thinking on this?",
          "createdAt": "2024-02-27T21:29:35Z",
          "updatedAt": "2024-02-27T21:29:35Z"
        },
        {
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Rejecting the request is a clear signal to the operator (and client author) that something is amiss.\r\n> \r\n> @beautifulentropy Are you implying that it would be a meaningfully less clear signal for the Server to instead accept the newOrder request and omit `replaces` in the returned Order object? If so, please could you explain your thinking on this?\r\n\r\nI'm considering the scenario where the server strips the `replaces` field and returns it empty in the order object. In such cases, it might be challenging for clients to discern whether the server is actively processing and correctly omitting the replaces field as per the ARI specification, or if it's simply ignoring the field due to a faulty implementation.\r\n\r\nConsider the error responses we currently have as well. We respond `unauthorized` (401) when the new order comes from an account that didn't request the certificate being replaced. Similarly, we respond `malformed` (400) when the new order contains no matching identifiers. Extending this logic, it would be consistent to respond with `conflict` (409) when the ACME account in question has already made a new order that replaces this certificate, no?",
          "createdAt": "2024-02-27T22:43:43Z",
          "updatedAt": "2024-02-27T22:49:00Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The HTTP 409 Conflict response status code indicates a request conflict with the current state of the target resource.\r\n\r\nOK, I can accept that _\"has already made a new order that replaces this certificate\"_ represents a _\"request conflict with the current state of the target resource\"_.  Due to this conflict, the `replaces` field in the request cannot be accepted and included in the _\"target resource\"_ (i.e., the new Order object) by the server.\r\n\r\nBut isn't this equally true for every reason a server might have for not accepting the `replaces` field in the request?  (e.g., if the server determines that these conditions are not met: _\"the identified certificate and the current New Order request correspond to the same ACME Account and share identifiers\"_).\r\n\r\nISTM that the nondeterminism of sometimes returning 409 and sometimes ignoring the `replaces` field in the request could lead to confusion.  So if we're going the 409 route, then I think I would prefer to specify a requirement along the lines of \"If the request contains a 'replaces' value that is unacceptable to the server, then the server MUST return HTTP 409 (Conflict) with a problem document that explains the reason for rejecting it\", together with some new error types (suggested names: alreadyReplaced, wrongAccount, and identifiersNotShared).",
          "createdAt": "2024-03-01T12:36:17Z",
          "updatedAt": "2024-03-01T12:36:17Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> But isn't this equally true for every reason a server might have for not accepting the replaces field in the request?\r\n\r\nIn my opinion, it's not equivalent. The distinction in my mind is as follows:\r\n- Some \"replaces\" fields the server _will not_ process, due to server policy -- the identified certificate was issued to the wrong account, or with a non-overlapping set of names, or any other reason that the server determines.\r\n- Some \"replaces\" fields the server _would_ process, because they meet all the criteria... but it cannot, because the identified certificate has already been replaced.\r\n\r\nThe former can be handled with a `malformed` error and a 400 response code. However, the latter are truly well-formed, but a conflict has arisen -- the previous certificate has already been updated to point at a new order that replaces it -- and so a 409 response code (and maybe a new acme error type?) is appropriate.\r\n\r\nIn my perception, the semantics of the HTTP 409 Conflict status code are truly limited to essentially race conditions: that response code is only appropriate if you're expecting a resource to be in a particular state, but it isn't in that state when you go to update it. That's only satisfied by the \"we would be happy to update the previous certificate, but we can't because it's already replaced\" condition, so I don't think it's appropriate to use 409 for the other error conditions.",
          "createdAt": "2024-03-04T20:01:21Z",
          "updatedAt": "2024-03-04T20:01:43Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> - Some \"replaces\" fields the server will not process, due to server policy -- the identified certificate was issued to the wrong account, or with a non-overlapping set of names, or any other reason that the server determines.\r\n> - Some \"replaces\" fields the server would process, because they meet all the criteria... but it cannot, because the identified certificate has already been replaced.\r\n\r\nI disagree that a server \"cannot\" in that second scenario.  Choosing to reject a `replaces` value because the identified certificate has already been replaced is also down to server policy (_\"Servers MAY ignore the replaces field in New Order requests which do not pass such checks\"_; note that \"MAY\" does not dictate required behaviour).  But having said that...\r\n\r\n> The former can be handled with a malformed error and a 400 response code\r\n\r\nIf we're in agreement that servers MUST always return an error when rejecting a submitted `replaces` value, then I don't object to using 409 just for the \"already renewed\" case and 400 for other error conditions.  I'll let you paint the bikeshed.  ;-)",
          "createdAt": "2024-03-06T15:04:05Z",
          "updatedAt": "2024-03-06T15:04:05Z"
        },
        {
          "author": "felixfontein",
          "authorAssociation": "NONE",
          "body": "Sorry for being (very) late to this discussion, but:\r\n\r\n> The CA should return a 409 when an existing replacement order is already Finalized, Pending, Ready, or Processing. If that order becomes Invalid, another replacement order can be made.\r\n\r\nWould it be possible to provide the URL of that order in the error document or some HTTP header? That would allow clients to continue with that order (after checking that it's indeed what they want) instead of having to retry without `replaces`.",
          "createdAt": "2024-08-15T18:32:03Z",
          "updatedAt": "2024-08-15T18:32:03Z"
        },
        {
          "author": "gregtwallace",
          "authorAssociation": "NONE",
          "body": "I was working on some code to implement this yesterday and am glad to see others have realized the same issue I came here to report.\r\n\r\nThat said, I would suggest possibly defining a new specific error for:\r\n\r\n> Some \"replaces\" fields the server will not process, due to server policy -- the identified certificate was issued to the wrong account, or with a non-overlapping set of names, or any other reason that the server determines.\r\n\r\nMaybe something like `malformed:replaces`. This would make it obvious the issue isn't some other type of 'malformed'.",
          "createdAt": "2024-08-16T22:42:47Z",
          "updatedAt": "2024-08-16T22:42:47Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOGGBRNc6AhnV7",
      "title": "What exactly does \"share identifiers\" mean?",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/57",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I wish I'd seen https://github.com/aarongable/draft-acme-ari/commit/8b464ffe1c5754f43a85bec7bc50ccbfafd44e64 (Remove \"a preponderance of\") yesterday, before I spent time mulling over how to interpret it!  :-)\r\n\r\nI'm not sad to see that somewhat archaic word ditched, but the wording after that commit leaves me even more unsure of what's expected.\r\n\r\nWith \"a preponderance of\", I'd concluded yesterday that >50% of the identifiers in the newOrder request must match identifiers in the certificate identified by `replaces`, or else the Server would ignore `replaces`.  (I'd also concluded that \"preponderance\" was vague enough that it would also make sense for that \">50%\" figure to be configurable, per Server, anywhere between \">50%\" and \"100%\").\r\n\r\nBut what exactly does \"share identifiers\" mean?\r\nDoes the newOrder request have to have the exact same set of identifiers as the certificate identified by `replaces`, with zero identifiers dropped and zero identifiers added?  (If so, then I'd suggest tightening the wording to \"share the exact same set of identifiers\" or something similar).\r\nOr is it intended that defining the meaning of \"share identifiers\" should be left to each individual Server's policy?  (If so, then I'd suggest adding to wording to explicitly say this).",
      "createdAt": "2024-02-27T11:00:21Z",
      "updatedAt": "2024-03-15T22:25:14Z",
      "closedAt": "2024-03-15T22:25:14Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Yeah, I changed it from \"share a preponderance of identifiers with\" to just \"share identifiers with\" to allow more freedom in server policy. I think that all of the following would be reasonable policies for a server to have:\r\n1) The replacement must have exactly the same identifiers\r\n2) The replacement must be a strict subset of the identifiers (i.e. all names have been issued for previously, but allowing names to be discontinued)\r\n3) The replacement must share most / a preponderance of the identifiers (essentially \"shrug, seems like a spiritual successor\")\r\n4) The replacement must share at least one identifier (as long as any name is being renewed, it counts)\r\n\r\nI agree that it should be clearer that exactly what approach is taken is left up to server policy. I'll work on some language.",
          "createdAt": "2024-03-05T22:35:48Z",
          "updatedAt": "2024-03-05T22:35:48Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that leaving it up to server policy makes sense, given that what a server should do with an accepted `replaces` value is also left up to server policy.",
          "createdAt": "2024-03-06T14:49:05Z",
          "updatedAt": "2024-03-06T14:49:05Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOGGBRNc6AjWqD",
      "title": "Certificate Renewal, Re-Key, Modification",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/58",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When draft-acme-ari says \"renewal\" or \"renew\", I'm guessing the intended meaning is any combination of (in RFC3647 terms) Renewal and/or Re-Key and/or Modification:\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc3647.html#section-4.4.6 (Certificate Renewal)\r\n>   Certificate renewal means the issuance of a\r\n>   new certificate to the subscriber without changing the subscriber or\r\n>   other participant's public key or any other information in the\r\n>   certificate:\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc3647.html#section-4.4.7 (Certificate Re-Key)\r\n>   ...generating a new key pair and\r\n>   applying for the issuance of a new certificate that certifies the new\r\n>   public key:\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc3647.html#section-4.4.8 (Certificate Modification)\r\n>   ...the issuance of a new certificate (6) due to changes in the\r\n>   information in the certificate other than the subscriber public key\r\n\r\nAssuming I've guessed correctly, and in the interest of avoiding confusion amongst implementors, observers, and auditors...\r\nShould draft-acme-ari be revised so that its terminology is aligned with RFC3647's terminology?\r\nOr would it be enough to add a single sentence to draft-acme-ari along the lines of \"In this document, 'renewal' is taken to encompass any combination of Renewal, Re-Key, and Modification [RFC3647]\" ?\r\n\r\nRelatedly, I think it's good that the new field in the Order object is named `replaces` rather than `renews`, since (unlike \"Certificate Renewal\"), \"Certificate Replacement\" is not an RFC3647 term with a different scope.",
      "createdAt": "2024-02-27T14:32:48Z",
      "updatedAt": "2024-03-15T21:54:48Z",
      "closedAt": "2024-03-15T21:54:48Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "This is a good point. FWIW, Caddy/Certmagic stacks now rotate the private key each time a certificate is renewed (by default; this is configurable). So we'll be re-keying often.",
          "createdAt": "2024-02-27T14:37:54Z",
          "updatedAt": "2024-02-27T14:37:54Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Or would it be enough to add a single sentence to draft-acme-ari along the lines of \"In this document, 'renewal' is taken to encompass any combination of Renewal, Re-Key, and Modification [RFC3647]\" ?\r\n\r\nYeah, I think this is the best approach.",
          "createdAt": "2024-03-05T22:39:33Z",
          "updatedAt": "2024-03-05T22:39:33Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOGGBRNc6BVOKs",
      "title": "Note up-from that this document assumes RFC 5280 profile",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/59",
      "state": "CLOSED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Specifically, 5280 requires that the AKID extension and its keyIdentifier field be present, and this spec relies on that field being present.",
      "createdAt": "2024-03-05T17:54:13Z",
      "updatedAt": "2024-03-15T22:01:11Z",
      "closedAt": "2024-03-15T22:01:11Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "I_kwDOGGBRNc6BcUKo",
      "title": "Advice to clients: Can the same \"clear predecessor certificate\" be identified in multiple New Order requests?",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/60",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In #57 we seem to be in agreement that it should be left to server policy to decide whether or not the identifier list in a New Order request and its claimed predecessor certificate _\"share identifiers\"_.  Similarly, the current language that affects client behaviour (_\"Clients SHOULD include this field in New Order requests if there is a clear predecessor certificate\"_) implies that it's left to client policy when a client is deciding if/how to populate the `replaces` field in a New Order request.\r\n\r\nConsider this scenario: A client has a soon-to-expire certificate (X) that has SAN:dNSName entries for a.com and b.com.  Instead of getting a like-for-like replacement, the client wishes to \"renew\" that certificate by ordering two new single-domain certificates - one cert for a.com, and another cert for b.com.  That client's policy is (quoting one of the suggested example policies in #57) \"The replacement must share at least one identifier (as long as any name is being renewed, it counts)\".  For both New Order requests, the client indicates certificate X in the `replaces` field, because it considers X to be the _\"clear predecessor certificate\"_ in both cases.\r\n\r\nGiven that _\"Servers SHOULD check...that the identified certificate has not already been marked as replaced by a different finalized Order\"_, ISTM that it would be worth providing more advice to clients regarding how to determine what is or isn't a _\"clear predecessor certificate\"_.\r\n\r\nSince _\"Servers MAY ignore the replaces field in New Order requests which do not pass such checks\"_ implies that servers are free to choose to regard multiple New Order requests as renewals of the same predecessor certificate, ISTM that the advice to clients should be: Be aware that some servers may reject a `replaces` value that has already been specified in a previous New Order request.\r\n\r\nI realise this is closely related to #56, although that issue is about server behaviour.",
      "createdAt": "2024-03-06T14:47:17Z",
      "updatedAt": "2024-03-15T22:40:25Z",
      "closedAt": "2024-03-15T22:40:25Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Since \"Servers MAY ignore the replaces field in New Order requests which do not pass such checks\" implies that servers are free to choose to regard multiple New Order requests as renewals of the same predecessor certificate\r\n\r\nI don't think this interpretation is supported by the draft text. Saying that a server MAY ignore the \"replaces\" field means that the server can choose to process the new-order request _ignoring_ the replaces field -- i.e. the Order object it returns will have an empty replaces field. Therefore the server does _not_ regard this order as a renewal of the same predecessor certificate, even though the client requested it. This is in contrast to the server's other option, which is to reject this second request as invalid (see the thread about 409 Conflict).\r\n\r\nI'm going to ignore this issue for the moment, because we have a bunch of other issues circulating about server behavior and it's not worth clarifying client behavior until we know exactly what the server's options are in this case.",
          "createdAt": "2024-03-06T17:26:40Z",
          "updatedAt": "2024-03-06T17:26:40Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I now understand your intended meaning, but I disagree that my interpretation is unsupported by the current text.  +1 on returning to this later though.",
          "createdAt": "2024-03-07T17:29:38Z",
          "updatedAt": "2024-03-07T17:29:38Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "I've now rephrased the whole block of text under the sample new-order request, and I think this is much clearer. Servers are now told that they SHOULD reject new-order requests whose identified predecessor certificate does not match their server-policy-based checks. I think client behavior is now clear: don't submit a value that the server will reject; if the server does reject, you can retry without it. I don't think that it's necessary to spell this out.\r\n\r\nThere's still some question here of whether or when a server should specifically return a 409, and whether there should be a new acme error type for this case, but that can be handled in #56 ",
          "createdAt": "2024-03-15T22:40:25Z",
          "updatedAt": "2024-03-15T22:40:25Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOGGBRNc6Bc7qT",
      "title": "Wordsmithing the suggested uses of `replaces` by a server",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/61",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Current text:\r\n> It is suggested that Servers should use this information to grant New Order requests which arrive during the suggested renewal window of their identified predecessor certificate higher priority or allow them to bypass rate limits, if the Server's policy uses such.\r\n\r\nI realise this is a not-upper-case \"should\" and it's prefixed by \"It is suggested\", but TBH I'd characterise this language as being slightly more prescriptive than something like \"What to do with this information is left entirely to server policy, but here are some suggestions:\".  Is that the intent?\r\n\r\nAlso, ISTM that the \"...should...higher priority...bypass rate limits\" language is geared towards high volume issuers, which not all server operators are.  Indeed, a server might not have any mechanisms for assigning higher priority or for bypassing rate limits, but might want to \"use this information\" in other ways.  For example, some CAs tend to extend the lifetime of a renewed certificate by the amount of time left on the predecessor certificate, which makes sense in cases where there is monetary value associated with the renewal.\r\n\r\nCould we rephrase this text to something like \"What to do with this information is left entirely to server policy, but here are some suggestions:\", followed by some bullet points?",
      "createdAt": "2024-03-06T15:55:10Z",
      "updatedAt": "2024-03-15T22:25:14Z",
      "closedAt": "2024-03-15T22:25:14Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Great suggestion, and I want to add/clarify:\r\n\r\n> ISTM that the \"...should...higher priority...bypass rate limits\" language is geared towards high volume issuers\r\n\r\nIt's also about cramming significantly more issuances into a narrow window that may push a CA beyond its issuance capacity, leaving some clients unable to renew in time.",
          "createdAt": "2024-03-06T19:21:47Z",
          "updatedAt": "2024-03-06T19:22:23Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Could we rephrase this text to something like \"What to do with this information is left entirely to server policy, but here are some suggestions:\", followed by some bullet points?\r\n\r\nMakes sense to me.\r\n\r\n> It's also about cramming significantly more issuances into a narrow window that may push a CA beyond its issuance capacity, leaving some clients unable to renew in time.\r\n\r\nOnly if the server makes the ARI window narrower than it can handle. As always, it is up to the server to ensure that it can handle its traffic volume and fail gracefully -- which many servers use rate limits to accomplish today -- and the existence of ARI does nothing to change that.",
          "createdAt": "2024-03-06T20:09:54Z",
          "updatedAt": "2024-03-06T20:09:54Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOGGBRNc6C-rhB",
      "title": "Conveying renewal urgency on a per-account basis",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/65",
      "state": "CLOSED",
      "author": "djc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am the CTO of Instant Labs, we host some ~1500 domains with sites for our customers. I wrote the [instant-acme](https://github.com/instant-labs/instant-acme) client for our use cases. As such, I have followed the developments around ARI with some interest. Personally I feel that making one request per certificate appears to be quite wasteful, and like @mholt in their recent email thread (https://mailarchive.ietf.org/arch/msg/acme/AeJ3zJKcBF-ZUhQXJajC0bb7orI/) I wonder if there isn't a better way to do this?\r\n\r\nI briefly discussed with Jacob HA whether it would be feasible to have a per-account endpoint that would just yield all the certificates that need updating in the next time window, but he mentioned that this would lead to highly variable response times which would be inconvenient for servers.\r\n\r\nWhich leads me to this proposal: would it be feasible to have an endpoint that just identifies the first certificate which needs renewal along with the date/time on which it should renew? This would allow clients to make a request to this endpoint and immediately go back to sleep until the given date/time.\r\n\r\n(Our current approach is storing the certificate expiry explicitly in our database alongside the certificate, we wake up a worker process every few hours to query all certificates that expire in the next 30 days and start the renewal process. Under my proposal, our worker process would check the first-renewal endpoint when it is first started, wait until the window arrives and then run again. If the window has arrived, it would do the renewal and look at the first-renewal endpoint again, etc.)",
      "createdAt": "2024-03-20T12:55:03Z",
      "updatedAt": "2024-07-18T23:36:51Z",
      "closedAt": "2024-07-18T23:36:51Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "I appreciate making things easier for clients.\n\nIf I understand correctly you're asking if the endpoint can simply tell the account owner when their next certificate renewal needs to be. Then after that cert is renewed, when is the next one? And so on.\n\nOne question I have is, What if the renewal date gets bumped earlier than the date from the first check?\n\n",
          "createdAt": "2024-03-20T14:36:28Z",
          "updatedAt": "2024-03-20T14:36:28Z"
        },
        {
          "author": "djc",
          "authorAssociation": "NONE",
          "body": "> One question I have is, What if the renewal date gets bumped earlier than the date from the first check?\r\n\r\nFair point. I guess maybe the server would want to provide some retry-after like value that is indepent from the next certificate? This still seems like an improvement because it gives the server more control over how often clients check in. In either case, it reduces the overhead from per-outstanding certificate to per-account, which seems like an improvement.",
          "createdAt": "2024-03-20T14:47:13Z",
          "updatedAt": "2024-03-20T14:48:24Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "There is something nice about the idea of just polling an endpoint per-account, though.\r\n\r\n**Client:** Poll. (\"Anything to renew?\")\r\n**Server:** Nope.\r\n(repeat N times...)\r\n**Client:** Poll.\r\n**Server:** Renew these certs!\r\n**Client:** _does so now_\r\n**Client:** Poll.\r\n**Server:** And now renew this one!\r\n**Client:** _does it_\r\n**Client:** Poll.\r\n**Server:** Nothing to renew right now.\r\n...\r\n\r\nIt does feel awkward to split scheduling between client and server, it feels like the server should just take charge of scheduling renewals instead of clients having to mix their own scheduling with a server's scheduling.\r\n\r\nOne problem with this could be a properly-positioned attacker -- or a network outage -- could simply drop packets or connections to the ARI server. Then again, that attacker could drop packets for the actual renewal transaction as well; so maybe not a huge concern.\r\n\r\nEither way, ARI is going to involve lots of polling.",
          "createdAt": "2024-03-20T15:05:10Z",
          "updatedAt": "2024-03-20T15:05:10Z"
        },
        {
          "author": "djc",
          "authorAssociation": "NONE",
          "body": "> It does feel awkward to split scheduling between client and server, it feels like the server should just take charge of scheduling renewals instead of clients having to mix their own scheduling with a server's scheduling.\r\n\r\nSure, but in that case we don't solve the issue of the midnight thundering herd, I presume? (Potentially it alleviates the issue if the first-renewal endpoint is cheaper to execute?)",
          "createdAt": "2024-03-20T15:07:18Z",
          "updatedAt": "2024-03-20T15:08:14Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Well and part of me has wondered -- and I think I mentioned this in that email thread earlier -- if there'd be some benefit to making ARI part of the normal ACME order workflow. Moving \"replaces\" into the Order object in draft-03 has already started that. I could imagine doing without a separate ARI endpoint, and instead the client just starts the renewal and sets the \"replaces\" field on the Order. If the server sees the \"replaces\" field populated but the ARI logic internally says it's not time yet, the server can simply respond with a graceful Retry-After (or something) and reject the new order. In other words, setting \"replaces\" tells the server that the client is honoring ARI and is just seeing if it's time to renew; if so, please renew, if not, we'll try again later.\r\n\r\nI don't remember if I was convinced that a separate endpoint is really needed. I can't recall a reason why it can't just be wrapped up in the existing ACME flow.",
          "createdAt": "2024-03-20T15:12:00Z",
          "updatedAt": "2024-03-20T15:12:00Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "(This is a fascinating discussion, just noting that I'm on vacation and will reply mid-next-week.)",
          "createdAt": "2024-03-21T00:20:39Z",
          "updatedAt": "2024-03-21T00:20:39Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Which leads me to this proposal: would it be feasible to have an endpoint that just identifies the first certificate which needs renewal along with the date/time on which it should renew? This would allow clients to make a request to this endpoint and immediately go back to sleep until the given date/time.\r\n\r\nIn my opinion, this defeats one of the purposes of ARI: that the window may shift at any time, in response to load spikes, predicted future load, revocation events, or otherwise. Simply sleeping until the indicated ARI time, without continuing to poll in the meantime, may cause clients to miss updates to the ARI suggested window.\r\n\r\nAs Matt suggested, the next obvious development from here is \"what if we polled once per account instead of once per certificate?\". I see two possible return values for this per-account polled endpoint:\r\n1. It returns the single next certificate to renew. During a mass revocation event, a client which only polls the per-account endpoint every X minutes could easily fall behind, and a client which re-polls the per-account endpoint after each replacement would end up making just as many queries as one which is polling on a per-certificate basis.\r\n2. It returns the whole collection of certificates which should be renewed right now. This results in all the same highly-variable response times, highly-variable response sizes, and paging issues as we've discussed before.\r\n\r\nAs may be obvious, I don't love either of these options.\r\n\r\n> In other words, setting \"replaces\" tells the server that the client is honoring ARI and is just seeing if it's time to renew; if so, please renew, if not, we'll try again later.\r\n\r\nThis brings no benefit. It only reduces the number of requests across the lifetime of a certificate by 1: the final \"should I renew? yes. okay here's the new order\" request pair becomes a single \"here's a new order\" which gets accepted instead of rejected. But all of the preceding requests become much heavier-weight requests containing significantly more data (and JWSes!), and all of the preceding replies become much more confusing error responses with limited data encoded in headers instead of meaningful data encoded in a dedicated JSON object.\r\n\r\nAlso, it prevents third-party monitors from ever being able to make an ARI request, which was one of the earliest design goals advocated for in early feedback.\r\n\r\n-----\r\n\r\nRight now, I still don't see a clean and reasonable way to do bulk ARI. It's just not in line with how the rest of the ACME protocol thinks about orders and certificates.",
          "createdAt": "2024-03-26T23:23:18Z",
          "updatedAt": "2024-03-26T23:23:18Z"
        },
        {
          "author": "djc",
          "authorAssociation": "NONE",
          "body": "> As Matt suggested, the next obvious development from here is \"what if we polled once per account instead of once per certificate?\". I see two possible return values for this per-account polled endpoint:\r\n> \r\n> 1. It returns the single next certificate to renew. During a mass revocation event, a client which only polls the per-account endpoint every X minutes could easily fall behind, and a client which re-polls the per-account endpoint after each replacement would end up making just as many queries as one which is polling on a per-certificate basis.\r\n> \r\n> 2. It returns the whole collection of certificates which should be renewed right now. This results in all the same highly-variable response times, highly-variable response sizes, and paging issues as we've discussed before.\r\n\r\nI think I was suggesting an enumerated response, which can either have\r\n\r\n* `checkBackIn`: next window when the client should check in, or\r\n* `renewCertificate`: a certificate ID that requires renewal, and the client should check in again after renewal\r\n\r\nThis would mean that \"idle\" clients (for which there are no upcoming renewals) can be given a longer window and only have to send one request per account (instead of one request per certificate), while \"busy\" clients (for which there are upcoming renewals) will hit the endpoint once after each renewal to find the next renewal.\r\n\r\nI guess a downside might be that very busy accounts (for which there is an upcoming renewal a majority of the time) are sort of \"rate-limited\"? Not sure if that would be perceived as a good thing or a bad thing?",
          "createdAt": "2024-03-27T13:40:39Z",
          "updatedAt": "2024-03-27T13:40:55Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Apologies for not replying to this last comment earlier.\r\n\r\n> I think I was suggesting an enumerated response, which can either have\r\n> \r\n> * `checkBackIn`: next window when the client should check in, or\r\n> * `renewCertificate`: a certificate ID that requires renewal, and the client should check in again after renewal\r\n\r\nI think this defeats too much of the purpose of ARI, and places _too much_ onus on the ACME server. The point is to give clients actionable information ahead of time, so that the clients can make intelligent decisions. If the only response a client gets is \"oops, now it's time to renew this one!\" it will be stuck in a constant tight loop, never making any headway. A client which queries ARI on a per-certificate basis and discovers that 100 certs all should be renewed in the same window can distribute those tasks to 100 different servers.\r\n\r\nWhile this proposal does resolve some of the variable-response-size concerns of other per-account polling proposals, I don't think it actually solves any real problems and certainly creates other problems.",
          "createdAt": "2024-07-18T23:36:51Z",
          "updatedAt": "2024-07-18T23:36:51Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOGGBRNc6FOgrn",
      "title": "Criteria for \"has not already been marked as replaced\"",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/66",
      "state": "CLOSED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5 currently says (emphasis mine):\r\n\r\n> Servers SHOULD check that the identified certificate and the New Order request correspond to the same ACME Account, that they share at least one identifier, and that the identified certificate has not already been marked as replaced by a different **pending or finalized** Order.\r\n\r\n\"pending\" is an [Order object status](https://datatracker.ietf.org/doc/html/rfc8555#section-7.1.3), but \"finalized\" is not.\r\n\r\nThere are a couple of problems with this language AIUI:\r\n- \"pending or finalized\" does not include the \"ready\" Order object state.\r\n- \"pending or finalized\" does include the subset of \"invalid\" Order objects that transitioned from \"processing\" to \"invalid\".\r\n\r\nHere are a couple of wordsmithing attempts for your consideration:\r\n\r\n1. ...by a different \"pending\", \"ready\", \"processing\", or \"valid\" Order.\r\n2. ...by a different Order that is not \"invalid\".",
      "createdAt": "2024-04-10T09:44:01Z",
      "updatedAt": "2024-04-11T15:01:28Z",
      "closedAt": "2024-04-11T15:01:28Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Thank you! This is a very good catch. I prefer your second proposal here, \"...by a different Order that is not \"invalid\".\"",
          "createdAt": "2024-04-10T22:03:07Z",
          "updatedAt": "2024-04-10T22:03:07Z"
        },
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @aarongable !",
          "createdAt": "2024-04-11T10:26:01Z",
          "updatedAt": "2024-04-11T10:26:01Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOGGBRNc6HxIA5",
      "title": "When to poll again if server does not send Retry-After?",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/69",
      "state": "CLOSED",
      "author": "mholt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 4.2 says:\r\n\r\n> The server SHOULD include a Retry-After header indicating the polling interval that the ACME server recommends. Conforming clients SHOULD query the renewalInfo URL again after the Retry-After period has passed, as the server may provide a different suggestedWindow.\r\n\r\nBecause of SHOULD instead of MUST, what should clients do for poll timing if the Retry-After header is omitted?\r\n\r\nThe only potentially relevant advice I can find is at the end of the section:\r\n\r\n> If the client receives no response or a malformed response (e.g. an end timestamp which is equal to or precedes the start timestamp), it SHOULD make its own determination of when to renew the certificate, and MAY retry the renewalInfo request with appropriate exponential backoff behavior.\r\n\r\nBut this seems to be related more to error handling and not a successful response without a Retry-After header. If we were to do exponential backoff as the norm (i.e. with successful responses), we'd likely end up hammering the endpoint at first and then potentially missing the window later!\r\n\r\nShould we poll every... hour? Day? 2 hours? 10 minutes? I guess I'm looking for what to do in practice here. Thanks",
      "createdAt": "2024-05-03T14:29:33Z",
      "updatedAt": "2024-07-18T23:16:00Z",
      "closedAt": "2024-07-18T23:16:00Z",
      "comments": [
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Thinking on this more, I wonder if a default poll interval of some ratio until the start of the suggestedWindow would make sense, since in general, we have no idea what timescales we'll be operating on.\r\n\r\nIf the system wakes every minute, you don't want to poll every time if the remaining certificate lifetime is on the order of weeks or months.\r\n\r\nIf the certificate lifetime is on the order of hours, you probably want to poll more often.",
          "createdAt": "2024-05-03T20:18:42Z",
          "updatedAt": "2024-05-03T20:18:42Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "I don't think this level of detail is worth specifying at the protocol level. Clients have been implementing polling, and servers have been implementing rate-limiting, since time immemorial. There are many good ways to do it, and many bad ways to do it, and I don't think it is within the purview of this small document to try to solve them.",
          "createdAt": "2024-05-20T23:21:59Z",
          "updatedAt": "2024-05-20T23:21:59Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOGGBRNc6HzC1g",
      "title": "Clarification of Retry-After, wake times, and polling intervals",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/70",
      "state": "CLOSED",
      "author": "mholt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Draft 3 says:\r\n\r\n> The following algorithm is RECOMMENDED for choosing a renewal time:\r\n> 1. Select a uniform random time within the suggested window.\r\n> ...\r\n> 5. Otherwise, sleep until the next normal wake time, re-check ARI, and return to Step 1.\r\n\r\n(Step \"2.\" above is actually step 5, I dunno why it shows up as 2, I definitely wrote 5)\r\n\r\nAnyway, if step 5 is reached, it says to wait until the next waking time, and then \"re-check ARI.\" What does this mean exactly? Poll the endpoint to get the updated info, or to use the previously-polled window that is stored in a cache of some sort? If it is the former, wouldn't we only poll with respect to Retry-After (if set)?\r\n\r\nThen, when returning to step 1, we are supposed to choose a new random time within the window. Is that intended? Or is the intention that we choose just 1 random time in the window, then store that (until the window changes) and reuse it, checking against that time when running the algorithm? I guess generating a random time each waking is no more and no less random than choosing 1 random time and reusing it until the window changes.\r\n\r\nThanks, hoping to gain some clarity on these things.",
      "createdAt": "2024-05-03T19:34:34Z",
      "updatedAt": "2024-05-03T22:17:45Z",
      "closedAt": "2024-05-03T22:17:45Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> (Step \"2.\" above is actually step 5, I dunno why it shows up as 2, I definitely wrote 5)\r\n\r\nYeah, that's just markdown being markdown.\r\n\r\n> What does this mean exactly?\r\n\r\nThis is a good point. It seems intuitively obvious -- query the ARI endpoint -- but you're right that the section (because it is oriented around describing the RenewalInfo object, rather than client flows) doesn't make that clear. I'll add a new Step 0 which explicitly says that a client should begin by querying the ARI endpoint.\r\n\r\n> Then, when returning to step 1...\r\n\r\nNo, the point is that you're not returning to step 1. You're querying the ARI endpoint again, and once you have that response, you then begin at step 1.",
          "createdAt": "2024-05-03T22:15:52Z",
          "updatedAt": "2024-05-03T22:15:52Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOGGBRNc6HzQHf",
      "title": "Recommended algorithm may lead to renewals outside of suggested window",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/71",
      "state": "CLOSED",
      "author": "mholt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Maybe this is OK, since the window is only a suggestion, but I noticed that this algorithm in section 4.2:\r\n\r\n> 1. Select a uniform random time within the suggested window.\r\n> 2. If the selected time is in the past, attempt renewal immediately.\r\n> 3. Otherwise, if the client can schedule itself to attempt renewal at exactly the selected time, do so.\r\n> 4. Otherwise, if the selected time is before the next time that the client would wake up normally, attempt renewal immediately.\r\n> 5. Otherwise, sleep until the next normal wake time, re-check ARI, and return to Step 1.\r\n\r\ncan result in clients renewing before the renewal window.\r\n\r\nLet's say the client wakes up once every 24 hours (that's very infrequent, but for the purposes of this discussion let's go with this). It wakes up 23 hours before the start of the renewal window, and 23.1 hours before the selected time (it happened to be toward the very beginning of the window). Step 2 is out because it's in the future. Let's say step 3 is out too, since it can't schedule itself. Step 4 then says to perform renewal immediately, which is still 23 hours before the renewal window even starts.\r\n\r\nIs that acceptable? Or should the client wait until it's in the renewal window (but then miss the selected time, albeit just a little bit in this case)?\r\n\r\nMy code so far looks something like `cutoff := cert.ari.SelectedTime.Add(-cfg.certCache.options.RenewCheckInterval)`. So, of course, if `cert.ari.SelectedTime` is near the beginning of the window, and `cfg.certCache.options.RenewCheckInterval` is any amount large, the resulting `cutoff` is likely to be before the start of the window.\r\n\r\nYou know I'm in favor of earlier renewals :slightly_smiling_face: , but I did want to seek clarification on this.",
      "createdAt": "2024-05-03T20:15:09Z",
      "updatedAt": "2024-05-03T23:01:07Z",
      "closedAt": "2024-05-03T22:23:42Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "1) Yes, the situation you describe is acceptable -- if it wasn't, I wouldn't have specified it.\r\n2) Note that the algorithm is merely RECOMMENDED. If you believe you have a better algorithm, then implementing that is perfectly acceptable.\r\n\r\nWe could amend the algorithm to say \"If the next time that the client would wake up normally is within the renewal window, do step 5\", but that extra layer of complexity didn't seem worthwhile to me.",
          "createdAt": "2024-05-03T22:23:42Z",
          "updatedAt": "2024-05-03T22:23:42Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Okay, thanks for clarifying. I'll roll with that then :+1:",
          "createdAt": "2024-05-03T23:01:06Z",
          "updatedAt": "2024-05-03T23:01:06Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOGGBRNc6Q_HOU",
      "title": "Support `replaces` without `renewal-info` resource",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/72",
      "state": "CLOSED",
      "author": "Radranic",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From a reading of the draft there is no explicit indication that a server supports the `replaces` tag on new orders.\r\n\r\nI've been told that it should be related to the `renewal-info` resource, but from what I read of the draft that relation is not explicit. \r\n\r\nI also know this isn't just my understanding of the issue as at least one client (https://github.com/rmbolger/Posh-ACME/releases/tag/v4.24.0) that has added support for ARI is sending the `replaces` value to services without the `renewal-info` field.\r\n\r\nWhile a solution to this misunderstand could be to make the relation more explicit, I would prefer if the support for the `replaces` field could be advertised independently so that a server could choose to support this without explicitly needing to have a `renewal-info` endpoint if the server doesn't care when a renewal happens.",
      "createdAt": "2024-07-26T15:21:31Z",
      "updatedAt": "2024-08-16T14:41:40Z",
      "closedAt": "2024-08-16T12:32:05Z",
      "comments": [
        {
          "author": "rmbolger",
          "authorAssociation": "NONE",
          "body": ">  (https://github.com/rmbolger/Posh-ACME/releases/tag/v4.24.0) that has added support for ARI is sending the replaces value to services without the renewal-info field.\r\n\r\nPosh-ACME has indeed added support for ARI, but it shouldn't be sending the `replaces` value for new orders unless the server's directory endpoint has the `renewalInfo` endpoint.\r\n\r\nhttps://github.com/rmbolger/Posh-ACME/blob/6b0b3c1d584d0551ce724c2eba23f66d3476c539/Posh-ACME/Public/New-PAOrder.ps1#L201-L205",
          "createdAt": "2024-08-15T15:05:34Z",
          "updatedAt": "2024-08-15T15:05:34Z"
        },
        {
          "author": "Radranic",
          "authorAssociation": "NONE",
          "body": "Is that a confirmation that there is no intent to be able to support the `replaces` value without including the `renewalInfo` endpoint?",
          "createdAt": "2024-08-15T15:21:28Z",
          "updatedAt": "2024-08-15T15:21:28Z"
        },
        {
          "author": "rmbolger",
          "authorAssociation": "NONE",
          "body": "I would think that any ACME CA supporting the `replaces` value would implicitly be supporting the `renewalInfo` field since they're ultimately both part of the ARI spec. I don't see how else a client would know it was supported.",
          "createdAt": "2024-08-15T15:31:18Z",
          "updatedAt": "2024-08-15T15:31:18Z"
        },
        {
          "author": "mholt",
          "authorAssociation": "NONE",
          "body": "Also, when replaces is set, the server _SHOULD_ do some strict verifications to make sure the account is authorized to indicate a certificate is replaced, etc. So it (likely) follows that it should not be set if ARI is not supported at all. Setting it when it is not intended is grounds for errors.",
          "createdAt": "2024-08-15T15:39:35Z",
          "updatedAt": "2024-08-15T15:39:35Z"
        },
        {
          "author": "Radranic",
          "authorAssociation": "NONE",
          "body": "> I would think that any ACME CA supporting the `replaces` value would implicitly be supporting the `renewalInfo` field since they're ultimately both part of the ARI spec. I don't see how else a client would know it was supported.\r\n\r\nI am asking for this to be added. A way to indicate `replaces` is supported without needing `renewalInfo`.\r\n\r\n> Also, when replaces is set, the server _SHOULD_ do some strict verifications to make sure the account is authorized to indicate a certificate is replaced, etc. So it (likely) follows that it should not be set if ARI is not supported at all. Setting it when it is not intended is grounds for errors.\r\n\r\nI have never disagreed with the validation requirements.\r\n\r\nI am asking why both features of ARI are bound into the same setting? Why can they not be both separate features? Or maybe at least a way in the `renewalInfo` to indicate \"this server does not care when you renew your cert\".\r\n\r\nThe way ARI is now, a server can't make use of order tracking via the replace without having to have some kind of logic to decide what \"good\" renewal info times are, even if the server is under no load constraints.\r\n\r\nMaybe add a field to the `meta` section of the directory similar to the `externalAccountRequired`. If it does not exist, replace is not supported, if it does exist and is true, then orders can be replaced.",
          "createdAt": "2024-08-15T18:27:18Z",
          "updatedAt": "2024-08-15T20:01:39Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Fundamentally, the purpose of this draft is not to enable order tracking, it's to enable rapid replacement of certificates. If someone is considering implementing _just_ the \"replaces\" field of this spec without implementing the renewal-info endpoint, I would encourage them to instead implement both.\r\n\r\nAt this time I do not intend to create a second separate indicator for whether or not the server supports the \"replaces\" field.\r\n\r\nI will update the document to indicate that clients SHOULD NOT include the \"replaces\" field in new-order requests if the server does not advertise a renewal-info endpoint in its directory.",
          "createdAt": "2024-08-15T23:28:10Z",
          "updatedAt": "2024-08-15T23:28:10Z"
        },
        {
          "author": "Radranic",
          "authorAssociation": "NONE",
          "body": "I get how the `renewalInfo` aims for those goals, but it's unfortunate that a useful feature such as `replaces` can't be used explicitly independently.\r\n\r\nFrom reading it I guess my only solution is to intentionally make an invalid `renewalInfo` or `suggestedWindow` inside it and hope that clients follow the \"SHOULD make its own determination\". \r\n\r\nI don't think Posh-ACME does proper checking on the suggested time in case the end is before the start, so an invalid response is probably the better bet.\r\n\r\nThank you for the conversation.\r\n\r\n",
          "createdAt": "2024-08-16T12:32:05Z",
          "updatedAt": "2024-08-16T12:32:05Z"
        },
        {
          "author": "rmbolger",
          "authorAssociation": "NONE",
          "body": "@Radranic If you think there's a problem with Posh-ACME's ARI implementation that should be fixed, feel free to create an issue [over there](https://github.com/rmbolger/Posh-ACME/issues). But we shouldn't clutter the RFC draft repo with that discussion.",
          "createdAt": "2024-08-16T14:06:02Z",
          "updatedAt": "2024-08-16T14:06:02Z"
        },
        {
          "author": "Radranic",
          "authorAssociation": "NONE",
          "body": "@rmbolger, I don't have any problem with the implementation. I was just mentioning that an example current implementation doesn't do something in that is marked as SHOULD for ARI, which limits ways to get around the \"must have renewalInfo\" requirement. \r\n\r\nI suspect a server that is intentionally trying to trigger failure case behavior of the RFC draft to trigger specific behaviors of a client isn't something that anyone here wants to specifically fix, so I'm not worried about the behavior.",
          "createdAt": "2024-08-16T14:41:39Z",
          "updatedAt": "2024-08-16T14:41:39Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOGGBRNc6UFYbF",
      "title": "Provide URL to replacing order on `alreadyReplaced` errors",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/73",
      "state": "OPEN",
      "author": "felixfontein",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It would be really helpful to client writers if a `alreadyReplaced` error would include the URL of the order that replaced the certificate.\r\n\r\nI'm not sure how expensive that would be to implement. I checked out Pebble, there the conflict is detected by checking a flag of the original order that's replaced. Using the ID of the replacing order instead of a boolean flag would be a rather simple change. I also checked Boulder; there a function `ReplacementOrderExists` is called to determine whether there's a replacing order, which basically only returns a boolean. I checked out its implementation, it also has the ID of the replacement order available, so it would be easy (as in: no DB changes, as data is already readily available) to change to also return that one.\r\n\r\nAs for how to return it, providing it as a `Location` header or as a part of the error document is both fine for me, as long as it is specified how it is returned :)",
      "createdAt": "2024-08-24T09:36:49Z",
      "updatedAt": "2024-08-24T09:36:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOGGBRNc6U8_M0",
      "title": "Update `alreadyReplaced` to `replaces` or similar",
      "url": "https://github.com/aarongable/draft-acme-ari/issues/74",
      "state": "CLOSED",
      "author": "gregtwallace",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Continuing the discussion from: https://github.com/aarongable/draft-acme-ari/issues/56\r\n\r\nTl'dr: If a client doesn't understand why the order is malformed, it would have to send a guess after removing the `replaces` field to see if that was the problem.\r\n\r\n---\r\n\r\nOther issues with the `replaces` field are currently ambiguous. Instead of defining `alreadyReplaced` define a single error such as `replaces` or `replacesField`. If the server returns 409 with this error, it is clear the certificate was already replaced. If the server returns any other error code with this error, it is clear the `replaces` field is the problem, but the certificate has not already been replaced.\r\n\r\nThis is helpful for telling clients that they MAY (or maybe even SHOULD) drop the `replaces` field and try again. If this doesn't exist and a client receives a generic error (e.g., `malformed`) the client would need to send the order again without `replaces` to find out if that was the malformed field or if there was a different issue.\r\n\r\nThis in turn will likely lead clients to perform the order again without the `replaces` field regardless of error, which will unncessarily double the new order request if the error was caused by something other than the `replaces` field.\r\n",
      "createdAt": "2024-08-31T19:20:06Z",
      "updatedAt": "2024-09-03T23:43:06Z",
      "closedAt": "2024-09-03T23:43:06Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Sorry, I don't understand what you're proposing. It sounds like you want to rename `urn:ietf:params:acme:error:alreadyReplaced` to `urn:ietf:params:acme:error:replacesField` (which doesn't sound like an error to me) and then have the meaning of that error be context-dependent depending on what HTTP error code accompanies the problem document? I don't understand the benefit this would bring and it would be a significant departure from how other ACME errors are used both in the specification and in practice.",
          "createdAt": "2024-09-03T17:12:10Z",
          "updatedAt": "2024-09-03T17:12:10Z"
        },
        {
          "author": "gregtwallace",
          "authorAssociation": "NONE",
          "body": "I'm not wed to any particular solution. I'm just trying to raise a potential issue for clients. \r\n\r\nThe scenario is there is an error with the `replaces` field on a submitted order that is NOT an already replaced error. For example, the server rejects the `replaces` field due to the list of identifiers not being a perfect match. This rejection should be distinguishable via a defined error vs. using a generic error like `malformed`. The client will see this defined error and know to remove the `replaces` field and resubmit the order. If the error is generic, the client would have to \"guess\" what the problem is, perhaps by removing the `replaces` field and retrying. In the event the generic error meant a problem other than `replaces` this is a pointless resubmission as it will just error again.\r\n\r\nPerhaps an error `badReplaces` or `malformedReplaces` might be a better name. I'm not familiar with the URN formatting, but maybe even something like `urn:ietf:params:acme:error:malformed:replaces`.",
          "createdAt": "2024-09-03T22:17:39Z",
          "updatedAt": "2024-09-03T22:19:39Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Ah thank you, now I understand. I guess my question is:\r\n\r\n> This rejection should be distinguishable via a defined error vs. using a generic error like `malformed`.\r\n\r\nWhy? The rest of the ACME protocol does not make such distinctions -- today there are a dozen different reasons why a newOrder request might be rejected with reason `malformed`, and none of them are distinguishable. I don't believe that the `replaces` field should be special in that regard. And if the ACME Server does want to provide more detail, the problem document format already has a mechanism for that: subproblems. For example, a server could provide one subproblem for each field of the request which has an issue.\r\n\r\nThe reason we have a new `alreadyReplaced` error type is because it is describing a truly new condition: the request was fully valid, but the client and server state appear to be out of sync (the client believes the prior cert still needs to be replaced, while the server believes it already has been). I don't believe there's a need for other kinds of errors to reflect more generic issues that could arise with this field.",
          "createdAt": "2024-09-03T23:43:06Z",
          "updatedAt": "2024-09-03T23:43:06Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOGGBRNc4sKZ8o",
      "title": "Add -latest to mmark seriesinfo block",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/1",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I don't know mmark very well, but this seems to result in the version number getting put in the XML \"properly\" (it's not properly, but xml2rfc seems to manage it well enough).",
      "createdAt": "2021-09-22T23:04:40Z",
      "updatedAt": "2021-09-23T00:02:13Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "4df062dcc1e637df4cbc21945df8ec44abac4884",
      "headRepository": "martinthomson/draft-acme-ari",
      "headRefName": "fix-latest",
      "headRefOid": "07df018eb9ab4d7271a48c60dde042d1c2eab1cf",
      "closedAt": "2021-09-22T23:43:12Z",
      "mergedAt": "2021-09-22T23:43:12Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "903d7c4dc8cf9dbd571311bb31bfda2e557be905"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4tY3zm",
          "commit": {
            "abbreviatedOid": "07df018"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-22T23:40:53Z",
          "updatedAt": "2021-09-22T23:40:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOGGBRNc4sugPL",
      "title": "Construct renewalInfo URLs from directory+fingerprint",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/2",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Instead of providing renewalInfo URLs inside order objects, requiring\r\nthe ACME client to persist the URL in order to query it on a regular\r\nbasis, allow renewalInfo URLs to be constructable given only existing\r\nclient configuration (i.e. the URL of the directory) and the certificate\r\nitself.\r\n\r\nThis allows stateless clients to not need to persist additional data,\r\nand allows external monitoring tools to poll for renewal information\r\nwithout being privy to order objects, at the cost of requiring two API\r\ncalls (one for the directory, one for the renewalInfo) each time a\r\nclient checks in.\r\n\r\nPart of #4",
      "createdAt": "2021-10-05T22:01:25Z",
      "updatedAt": "2021-10-26T23:41:41Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "d4f774fbe92e0245fdff2a2ac7ac7082c4392237",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "constructed-urls",
      "headRefOid": "8273e4cec289358aba33134367ee110d0b11fba9",
      "closedAt": "2021-10-26T23:41:40Z",
      "mergedAt": "2021-10-26T23:41:40Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "e7a4e03b1c81f1823bc6f6c3692d13ccd5aeb73d"
      },
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "> Looks good! We should clarify a bit what we mean by hex-encoded: is lowercase acceptable?\r\n\r\nGood call. I've pulled \"case-insensitive hex-encoded\" out of the three bullet points to the paragraph above, and referenced RFC 4648, Section 8, for that.",
          "createdAt": "2021-10-26T23:39:03Z",
          "updatedAt": "2021-10-26T23:39:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4uBLCu",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "pgporada",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T23:03:38Z",
          "updatedAt": "2021-10-05T23:03:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "A client calling `/directory` should receive the renewal period advertised by the CA e.g. 12h. Maybe this is what `renewalInfo` does?",
              "createdAt": "2021-10-05T23:03:38Z",
              "updatedAt": "2021-10-05T23:05:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uBL__",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T23:11:39Z",
          "updatedAt": "2021-10-05T23:11:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Interesting, we could include that in directory metadata. Right now, this draft has the server's suggested check-in interval instead provided by the Retry-After header on the `renewalInfo` endpoint itself.",
              "createdAt": "2021-10-05T23:11:40Z",
              "updatedAt": "2021-10-05T23:11:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uBOGq",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T23:30:26Z",
          "updatedAt": "2021-10-05T23:30:26Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I think I should instead mandate that the renewalInfo URL in the directory end with a slash.",
              "createdAt": "2021-10-05T23:30:26Z",
              "updatedAt": "2021-10-05T23:30:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uEvUe",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T16:53:18Z",
          "updatedAt": "2021-10-06T16:53:19Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Also, my first implementation (https://github.com/letsencrypt/boulder/pull/5691) uses the same arguments as OCSP (issuerKeyHash, issuerNameHash, certificateSerial) instead of the full certificate fingerprint, because that's much easier for Let's Encrypt's specific setup. Should consider whether that is a better approach for everyone overall, too.",
              "createdAt": "2021-10-06T16:53:18Z",
              "updatedAt": "2021-10-06T16:53:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uFsel",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-06T21:29:45Z",
          "updatedAt": "2021-10-06T21:32:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I think `newNonce` here should be `renewalInfo` instead, right?\r\n\r\n```suggestion\r\nrenewalInfo   | Renewal info\r\n```",
              "createdAt": "2021-10-06T21:29:45Z",
              "updatedAt": "2021-10-06T21:32:10Z"
            },
            {
              "originalPosition": 70,
              "body": "Let's make the standard use the same arguments (issuerKeyHash, issuerNameHash, certificateSerial). We know all CAs need a cheap way to index off of those fields, so I suspect it will be a good approach for everyone.",
              "createdAt": "2021-10-06T21:31:37Z",
              "updatedAt": "2021-10-06T21:32:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uF82G",
          "commit": {
            "abbreviatedOid": "4ca27fe"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T23:19:35Z",
          "updatedAt": "2021-10-06T23:19:35Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "d'oh thanks, copy-paste error.",
              "createdAt": "2021-10-06T23:19:35Z",
              "updatedAt": "2021-10-06T23:19:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4uKGOR",
          "commit": {
            "abbreviatedOid": "8369115"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! We should clarify a bit what we mean by hex-encoded: is lowercase acceptable?",
          "createdAt": "2021-10-07T21:09:06Z",
          "updatedAt": "2021-10-07T21:09:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOGGBRNc4su5my",
      "title": "Require unauthenticated GET for renewalInfo requests",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/5",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do not allow POST-as-GET for accessing renewalInfo resources; instead\r\nrequire that servers only expose the resource via GET, and that clients\r\nonly query the resource via GET.\r\n\r\nThis reduces the possible implementation space for clients, simplifying\r\nthe work for client maintainers. It also ensures that the renewalInfo\r\nresponses can be easily cached, allowing server operators to minimize\r\nthe burden of supporting this draft.\r\n\r\nFixes #3",
      "createdAt": "2021-10-05T23:25:06Z",
      "updatedAt": "2021-10-26T23:54:48Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "e7a4e03b1c81f1823bc6f6c3692d13ccd5aeb73d",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "only-get",
      "headRefOid": "2affe0828ef920f721a8581a976ee4d0e689cea2",
      "closedAt": "2021-10-26T23:54:47Z",
      "mergedAt": "2021-10-26T23:54:47Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "885cab22773118af048de1e876466c28d85f72c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4uFtvL",
          "commit": {
            "abbreviatedOid": "0683f4e"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T21:37:13Z",
          "updatedAt": "2021-10-06T21:37:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOGGBRNc4uPzPv",
      "title": "Add current implementations section",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/11",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #10",
      "createdAt": "2021-11-08T19:34:12Z",
      "updatedAt": "2021-11-08T23:26:13Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "1a3f8503e04b44911429789fbe2d4cbe57ad4f21",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "curr-impl",
      "headRefOid": "7abc990fb6076d86855980e4ab4aa74a1771dc0a",
      "closedAt": "2021-11-08T23:26:13Z",
      "mergedAt": "2021-11-08T23:26:13Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "e9960911d9326f4afb61516289b6f51d33af6038"
      },
      "comments": [
        {
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2021-11-08T22:50:40Z",
          "updatedAt": "2021-11-08T22:50:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4vuUW1",
          "commit": {
            "abbreviatedOid": "7abc990"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-08T22:30:28Z",
          "updatedAt": "2021-11-08T22:30:32Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I'm not sure if this renders how you want it to. In my markdown preview I just get:\r\n```\r\nInternet Security Research Group\r\nInternet Security Research Group\r\n```\r\nIn Github something a bit different.",
              "createdAt": "2021-11-08T22:30:28Z",
              "updatedAt": "2021-11-08T22:30:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4vuXgQ",
          "commit": {
            "abbreviatedOid": "7abc990"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-08T22:50:36Z",
          "updatedAt": "2021-11-08T22:50:36Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I think this gets reprocessed by some tools on its way to becoming an uploadable draft. In plain Markdown, HTML tags gets passed straight through, but these tags don't have meaning in HTML (with the exception of `<title>`, which the browser probably says \"wat??\" upon seeing in the middle of a `<body>`)",
              "createdAt": "2021-11-08T22:50:36Z",
              "updatedAt": "2021-11-08T22:50:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4vucVX",
          "commit": {
            "abbreviatedOid": "7abc990"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-08T23:25:05Z",
          "updatedAt": "2021-11-08T23:25:05Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yeah, for better or worse, although this file is essentially markdown, it's not _rendered_ using markdown. The render pipeline is `markdown --mmark-> xml --xml2rfc-> rfc`, so what actually matters is what text and html output the render pipeline produces. You can see previews for each pull request on the github pages site for this repo: https://aarongable.github.io/draft-acme-ari/\r\n\r\nThis one is specifically https://aarongable.github.io/draft-acme-ari/curr-impl/draft-aaron-acme-ari.html, which you can see renders these inline as `[lestaging]` and `[boulder]`, with new matching Informative References at the bottom.",
              "createdAt": "2021-11-08T23:25:05Z",
              "updatedAt": "2021-11-08T23:25:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOGGBRNc4uP0FQ",
      "title": "Clarify client backoff/retry expectations",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/12",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #8",
      "createdAt": "2021-11-08T19:39:21Z",
      "updatedAt": "2021-11-08T23:35:04Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "1a3f8503e04b44911429789fbe2d4cbe57ad4f21",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "retry-behavior",
      "headRefOid": "0b7fe3d6c6ef6745a7d7f4c0f05cb72f6acf9b5a",
      "closedAt": "2021-11-08T23:35:03Z",
      "mergedAt": "2021-11-08T23:35:02Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "97b98d6e4cb90f74e597c0f490a4e224caef48a0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4vuWZK",
          "commit": {
            "abbreviatedOid": "d387a0b"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-08T22:43:11Z",
          "updatedAt": "2021-11-08T22:44:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would it be important to specify \"polling interval or datetime\"? Or refer to the specification for `Retry-After` that a client should use? (I realize this is adding some formatting bits to the existing wording, but thought it worth mentioning)",
              "createdAt": "2021-11-08T22:43:11Z",
              "updatedAt": "2021-11-08T22:44:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4vuYLu",
          "commit": {
            "abbreviatedOid": "d387a0b"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "It's useful to be really explicit about expectations or people won't get it. Added some suggested verbiage specific to cron-based clients.",
          "createdAt": "2021-11-08T22:55:21Z",
          "updatedAt": "2021-11-08T22:55:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nConforming clients **MUST** select a uniform random time within the suggested window to attempt to renew the certificate. If the selected time is in the past, the client **SHOULD** attempt renewal immediately. If the selected time is in the future, but before the next time that the client would wake up normally, the client **MAY** attempt renewal immediately. In all cases, renewal attempts are subject to the client's existing error backoff and retry intervals.\r\n\r\nIn particular, cron-based clients may find they need to increase their run frequency to check ARI more frequently. Those clients will need to store information about failures so that increasing their run frequency doesn't lead to retrying failures without proper backoff. Typical information stored should include: number of failures for a given order (defined by the set of names on the order), and time of the most recent failure.\r\n```",
              "createdAt": "2021-11-08T22:55:21Z",
              "updatedAt": "2021-11-08T22:55:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc4vuc04",
          "commit": {
            "abbreviatedOid": "d387a0b"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-08T23:28:59Z",
          "updatedAt": "2021-11-08T23:28:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah, I'm gonna leave this one as-is for now, but I've already filed https://github.com/aarongable/draft-acme-ari/issues/13 because I know this language isn't how I want it to be.",
              "createdAt": "2021-11-08T23:28:59Z",
              "updatedAt": "2021-11-08T23:28:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOGGBRNc4uQLzE",
      "title": "Clarify client behavior for malformed renewalInfo",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/14",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #9",
      "createdAt": "2021-11-08T21:57:21Z",
      "updatedAt": "2021-11-08T23:59:02Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "97b98d6e4cb90f74e597c0f490a4e224caef48a0",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "malformed-behavior",
      "headRefOid": "9b8dc181749678b534c195716e770830c85eceba",
      "closedAt": "2021-11-08T23:59:01Z",
      "mergedAt": "2021-11-08T23:59:01Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "57dbbd6f1ab506bf67b08785dcf5cb347615d498"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc4vuWtx",
          "commit": {
            "abbreviatedOid": "43c9aef"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-08T22:45:26Z",
          "updatedAt": "2021-11-08T22:45:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGGBRNc4vuYVm",
          "commit": {
            "abbreviatedOid": "43c9aef"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-08T22:56:26Z",
          "updatedAt": "2021-11-08T22:56:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOGGBRNc40oQXq",
      "title": "Use base64url(CertID) for path slug",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/21",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Change the format of the ARI request URL. The new format borrows\r\nmore directly from OCSP, being simply a base64url-encoding of the\r\nCertID sequence from within an OCSP request, but doing so makes\r\nthe specification of the format much simpler, and allows for algorithm\r\nagility.\r\n\r\nFixes #17\r\nFixes #18",
      "createdAt": "2022-03-17T23:07:31Z",
      "updatedAt": "2022-03-29T20:53:15Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "57dbbd6f1ab506bf67b08785dcf5cb347615d498",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "certid-for-url",
      "headRefOid": "1dd68b47064cdb16e3e3cc5de006f9185132c245",
      "closedAt": "2022-03-29T20:53:13Z",
      "mergedAt": "2022-03-29T20:53:13Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "e069d45ec5e19ab2746ae8b6dc2b578ba067473b"
      },
      "comments": [
        {
          "author": "andygabby",
          "authorAssociation": "NONE",
          "body": "It certainly is nice to make this closer to OCSP, the downside is that server operators will have to be aware that base64 has forward slashes as a possible character and they may be prone to [the problem of slash collapsing](https://community.letsencrypt.org/t/may-19-2017-ocsp-and-issuance-outage-postmortem/34922) with GET requests and base64. ",
          "createdAt": "2022-03-24T00:30:05Z",
          "updatedAt": "2022-03-24T00:30:05Z"
        },
        {
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This specifies base64url, which is an encoding without slashes (for that exact reason).",
          "createdAt": "2022-03-24T00:42:53Z",
          "updatedAt": "2022-03-24T00:42:53Z"
        },
        {
          "author": "andygabby",
          "authorAssociation": "NONE",
          "body": "Ah, thanks for the clarification.",
          "createdAt": "2022-03-24T03:55:06Z",
          "updatedAt": "2022-03-24T03:55:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc42eI0x",
          "commit": {
            "abbreviatedOid": "5947472"
          },
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-18T01:41:06Z",
          "updatedAt": "2022-03-18T01:45:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe full request URL is computed by concatenating the `renewalInfo` URL from the server's directory with a forward slash and the base64url-encoded [@!RFC4648, see, section 5] bytes of a DER encoded ASN.1 CertID sequence [@!RFC6960, see, section 4.1.1]. Trailing '=' characters MUST be stripped.\r\n```",
              "createdAt": "2022-03-18T01:41:07Z",
              "updatedAt": "2022-03-18T01:45:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc42glaP",
          "commit": {
            "abbreviatedOid": "5947472"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-18T15:23:50Z",
          "updatedAt": "2022-03-18T15:23:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was attempting to emulate this language from RFC6960, Appendix A.1:\r\n> url-encoding of base-64 encoding of the DER encoding of the OCSPRequest\r\n\r\nBut this does definitely make the sentence shorter and probably clearer",
              "createdAt": "2022-03-18T15:23:50Z",
              "updatedAt": "2022-03-18T15:23:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc42g7Rt",
          "commit": {
            "abbreviatedOid": "1dd68b4"
          },
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-18T16:34:40Z",
          "updatedAt": "2022-03-18T16:34:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGGBRNc42z81E",
          "commit": {
            "abbreviatedOid": "1dd68b4"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-24T00:25:34Z",
          "updatedAt": "2022-03-24T00:25:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOGGBRNc40rAeL",
      "title": "Add \"this has been renewed\" endpoint",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/22",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add a specification for POST behavior at the renewalInfo\r\nresource, so that clients can inform the server when they have\r\ncompleted renewal/replacement of a certificate.\r\n\r\nFixes #15",
      "createdAt": "2022-03-18T18:17:20Z",
      "updatedAt": "2022-03-30T15:12:17Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "f2441807343800161c3a93619300cb89f9cd9b2b",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "renewal-complete",
      "headRefOid": "018dd35fc7332dd041b4838dea8b1be6cb2180f3",
      "closedAt": "2022-03-30T15:12:17Z",
      "mergedAt": "2022-03-30T15:12:16Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "6410fba49a018098afb6234c6e068ba4e5084153"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc42hge4",
          "commit": {
            "abbreviatedOid": "72f616b"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Looking good! Left a few suggestions. The renewal complete endpoint would be pretty awesome if clients use it.",
          "createdAt": "2022-03-18T18:56:17Z",
          "updatedAt": "2022-03-18T19:32:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The word \"We\" here makes it a bit ambiguous to the general reader on if this spec is defining a new resource type or if somewhere else it has been defined as part of the ACME protocol. If it is the proposal of the spec consider another wording, perhaps just drop the \"We\".\r\n```suggestion\r\nDefine a new resource type, the \"`renewalInfo`\" resource, as part of the ACME protocol. This new resource both allows clients to query the server for suggestions on when they should renew certificates, and allows clients to inform the server when they have completed renewal (or otherwise replaced the certificate to their satisfaction).\r\n```",
              "createdAt": "2022-03-18T18:56:17Z",
              "updatedAt": "2022-03-18T19:14:34Z"
            },
            {
              "originalPosition": 25,
              "body": "I like that for `replaced` \"Clients SHOULD NOT send a request where this value is false\". Should we define that a server \"MUST NOT\", \"SHOULD NOT\" or even consider \"SHOULD\" change `replaced` from `true` to `false` or otherwise clarify how the server should behave if a Client asks it to set this to `false`? ",
              "createdAt": "2022-03-18T19:07:52Z",
              "updatedAt": "2022-03-18T19:15:37Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nThe server MUST verify that the request is signed by the account key of the Subscriber to which the certificate was originally issued. If the server accepts the request and the update succeeds, it responds with an HTTP 200 status code. If the update is rejected or fails, for example because the certificate has already been marked as renewed, the server returns an error.\r\n```",
              "createdAt": "2022-03-18T19:11:59Z",
              "updatedAt": "2022-03-18T19:14:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc42z-BK",
          "commit": {
            "abbreviatedOid": "72f616b"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-03-24T00:37:20Z",
          "updatedAt": "2022-03-24T00:42:14Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nTo update the renewal status of a certificate, the client sends a POST request to the server's `renewalInfo` URL.\r\n```",
              "createdAt": "2022-03-24T00:37:20Z",
              "updatedAt": "2022-03-24T00:42:14Z"
            },
            {
              "originalPosition": 23,
              "body": "Why not POST to a URL composed with that base64url-encoded path? Possibly even the same one that was GOTten?",
              "createdAt": "2022-03-24T00:38:39Z",
              "updatedAt": "2022-03-24T00:42:14Z"
            },
            {
              "originalPosition": 21,
              "body": "You should specify that the JWS object is authenticated to an account as defined in ACME.",
              "createdAt": "2022-03-24T00:39:17Z",
              "updatedAt": "2022-03-24T00:42:14Z"
            },
            {
              "originalPosition": 25,
              "body": "Also we should define \"replaced.\" Proposal: A certificate is considered replaced when its revocation will not affect any live services (for instance when all services using that certificate have started serving a different certificate).\r\n\r\nWe also might want to specify that it's fine to update this endpoint even if you didn't actually issue a new certificate - for instance if you don't care about the old certificate anymore because it's not in use.",
              "createdAt": "2022-03-24T00:40:20Z",
              "updatedAt": "2022-03-24T00:42:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc43JjqK",
          "commit": {
            "abbreviatedOid": "72f616b"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-29T21:21:21Z",
          "updatedAt": "2022-03-29T21:21:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I considered that! I ended up going with this just for consistency with other existing ACME methods, particularly the revocation endpoint, which is a POST to a bare endpoint with the body containing the full cert, rather than a POST to the certificate download URL. Obviously there are reasons for that (the original certificate download URL couldn't be deterministically constructed) but I thought that consistency might be valuable? Very unsure though and happy to be convinced otherwise.",
              "createdAt": "2022-03-29T21:21:22Z",
              "updatedAt": "2022-03-29T21:21:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc43JrCo",
          "commit": {
            "abbreviatedOid": "72f616b"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-29T21:58:33Z",
          "updatedAt": "2022-03-29T22:12:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's what I get for carrying over my academic writing style >_<\r\n\r\nI've rephrased the whole first sentence.",
              "createdAt": "2022-03-29T21:58:33Z",
              "updatedAt": "2022-03-29T22:12:36Z"
            },
            {
              "originalPosition": 47,
              "body": "Thanks for noting the inconsitency of phrasing between here and line 114. I've actually changed *both* of them to unify on a happy in-between :)",
              "createdAt": "2022-03-29T22:02:31Z",
              "updatedAt": "2022-03-29T22:12:36Z"
            },
            {
              "originalPosition": 19,
              "body": "Oops, thanks!",
              "createdAt": "2022-03-29T22:02:44Z",
              "updatedAt": "2022-03-29T22:12:36Z"
            },
            {
              "originalPosition": 21,
              "body": "Good idea, added a reference to RFC8555 Section 6.2.",
              "createdAt": "2022-03-29T22:08:03Z",
              "updatedAt": "2022-03-29T22:12:36Z"
            },
            {
              "originalPosition": 25,
              "body": "I've updated the phrasing here to try to get at this idea.",
              "createdAt": "2022-03-29T22:12:10Z",
              "updatedAt": "2022-03-29T22:12:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc43NXtN",
          "commit": {
            "abbreviatedOid": "c9f7cf4"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-30T14:46:38Z",
          "updatedAt": "2022-03-30T14:47:02Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Optional: Consider changing `intermediate certificate` back to `CA`. The word \"Intermediate Certificate\" isn't really used in ACME or the Baseline Requirements and \"CA\" or \"CA Certificate\" applies to the Appendix A.2 entry either way.",
              "createdAt": "2022-03-30T14:46:38Z",
              "updatedAt": "2022-03-30T14:47:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc43NhBI",
          "commit": {
            "abbreviatedOid": "c9f7cf4"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-30T15:10:08Z",
          "updatedAt": "2022-03-30T15:10:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yeah I changed it because I didn't want to bother defining the acronym \"CA\" anywhere. But yeah maybe it's just obvious enough as-is.",
              "createdAt": "2022-03-30T15:10:08Z",
              "updatedAt": "2022-03-30T15:10:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOGGBRNc40rCm9",
      "title": "Minor cleanups",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/23",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Update the date on the external references, remove the\r\nquotes from around the value of the Retry-After header,\r\nand remove phrasing referencing the document as a \"draft\"\r\n(which will just have to be updated sooner or later anyway).",
      "createdAt": "2022-03-18T18:28:56Z",
      "updatedAt": "2022-03-18T18:51:38Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "57dbbd6f1ab506bf67b08785dcf5cb347615d498",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "cleanups",
      "headRefOid": "ba3828d8da1dcd7cf2898b8075bea135603329ad",
      "closedAt": "2022-03-18T18:51:37Z",
      "mergedAt": "2022-03-18T18:51:37Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "bc08ed5a1efc61e8f8102abb6480dc235aaa5a81"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc42heAs",
          "commit": {
            "abbreviatedOid": "ba3828d"
          },
          "author": "andygabby",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-18T18:47:07Z",
          "updatedAt": "2022-03-18T18:47:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOGGBRNc40rKXp",
      "title": "Add explanationURL to renewalInfo",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/24",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add a new field to the renewalInfo response which allows a CA\r\nto provide an explanation for the suggested renewal window. Cert\r\nmonitors might use this information to inform whether or how they\r\nsend notifications to their customers.",
      "createdAt": "2022-03-18T19:11:02Z",
      "updatedAt": "2022-03-29T21:05:39Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "e069d45ec5e19ab2746ae8b6dc2b578ba067473b",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "explanation-url",
      "headRefOid": "799ba0764bd03dd2e6fd2b101931279d14871436",
      "closedAt": "2022-03-29T21:05:38Z",
      "mergedAt": "2022-03-29T21:05:38Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "f2441807343800161c3a93619300cb89f9cd9b2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc42hnus",
          "commit": {
            "abbreviatedOid": "4815d46"
          },
          "author": "jcjones",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thank you for producing the PR! I added slightly more context because this color of blue is my favorite",
          "createdAt": "2022-03-18T19:17:41Z",
          "updatedAt": "2022-03-18T19:20:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n`explanationURL` (string, optional): A URL pointing to a page which may explain why the suggested renewal window is what it is. For example, it may be a page explaining the CA's dynamic load-balancing strategy, or a page documenting which certificates are affected by a mass revocation event. Conforming clients **SHOULD** provide this URL to their operator, if present.\r\n```",
              "createdAt": "2022-03-18T19:17:42Z",
              "updatedAt": "2022-03-18T19:20:16Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n  \"explanationURL\": \"https://example.com/docs/mass-reissuance-extravaganza\"\r\n```",
              "createdAt": "2022-03-18T19:18:43Z",
              "updatedAt": "2022-03-18T19:20:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc42z-15",
          "commit": {
            "abbreviatedOid": "4815d46"
          },
          "author": "jsha",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-24T00:45:19Z",
          "updatedAt": "2022-03-24T00:45:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOGGBRNc44bTfM",
      "title": "Very minor word changes",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/29",
      "state": "MERGED",
      "author": "robplee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just addressing the couple of wording changes I suggested in #28 ",
      "createdAt": "2022-05-25T08:19:52Z",
      "updatedAt": "2022-06-13T21:05:46Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "6410fba49a018098afb6234c6e068ba4e5084153",
      "headRepository": "robplee/draft-acme-ari",
      "headRefName": "main",
      "headRefOid": "bc1419f96b42b93098d1d114963b0aa8501553b3",
      "closedAt": "2022-06-13T21:05:46Z",
      "mergedAt": "2022-06-13T21:05:45Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "6c53f5b24684b503011499aae8f8a8fddb14b84d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc475hN3",
          "commit": {
            "abbreviatedOid": "bc1419f"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for the edits, and sorry for the delay!",
          "createdAt": "2022-06-13T21:03:52Z",
          "updatedAt": "2022-06-13T21:03:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOGGBRNc45LryS",
      "title": "s/signature/hash",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/31",
      "state": "MERGED",
      "author": "osirisinferi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #30.",
      "createdAt": "2022-06-06T17:29:25Z",
      "updatedAt": "2022-06-13T21:26:47Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "6410fba49a018098afb6234c6e068ba4e5084153",
      "headRepository": "osirisinferi/draft-acme-ari",
      "headRefName": "hash-not-signature",
      "headRefOid": "5cfd40e67e4bcd435072ddf4ee7f2ea90f458aab",
      "closedAt": "2022-06-13T21:07:41Z",
      "mergedAt": "2022-06-13T21:07:41Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "19d14272dd585b03cafb2afa042a7247fe2ad0c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc475iDm",
          "commit": {
            "abbreviatedOid": "5cfd40e"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for catching and fixing this mistake!",
          "createdAt": "2022-06-13T21:05:19Z",
          "updatedAt": "2022-06-13T21:05:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOGGBRNc474-Jq",
      "title": "Clearly RECOMMEND time-selection algorithm",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/32",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #26",
      "createdAt": "2022-07-21T23:05:11Z",
      "updatedAt": "2022-07-22T17:26:08Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "19d14272dd585b03cafb2afa042a7247fe2ad0c2",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "recc-algo",
      "headRefOid": "fd501463589ea2efcae214f8040073d43ddcbb68",
      "closedAt": "2022-07-22T17:26:07Z",
      "mergedAt": "2022-07-22T17:26:07Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "cda2ad2d6574345bedb4e3935fa71dfa2bbc4939"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOGGBRNc475Fpr",
      "title": "Provide more explicit examples in introduction",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/33",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As suggested in https://mailarchive.ietf.org/arch/msg/acme/Hs2zvD4nrUmjf2dCNcs8f9ex-MU/",
      "createdAt": "2022-07-21T23:54:07Z",
      "updatedAt": "2022-07-22T17:26:51Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "19d14272dd585b03cafb2afa042a7247fe2ad0c2",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "more-justification",
      "headRefOid": "0d317351aac2a97d158cad37c24e0e70ed125847",
      "closedAt": "2022-07-22T17:26:50Z",
      "mergedAt": "2022-07-22T17:26:50Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "90a2b545d20f47a2bb5f43227241f11f5f79d636"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOGGBRNc49WhuV",
      "title": "Adopt draft into ACME WG",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/34",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Update metadata to reflect new name \"draft-acme-ari\".",
      "createdAt": "2022-08-17T21:22:49Z",
      "updatedAt": "2022-08-17T21:24:27Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "90a2b545d20f47a2bb5f43227241f11f5f79d636",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "adopt",
      "headRefOid": "9bbe4d8a3722ed6af883683c516bf396adebc9ee",
      "closedAt": "2022-08-17T21:24:26Z",
      "mergedAt": "2022-08-17T21:24:26Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "3889cef0fef0e1acb3d780a37ac9cfc19ff9be2f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOGGBRNc4945qS",
      "title": "Typo: Replace 'uniforn' with 'uniform'",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/35",
      "state": "MERGED",
      "author": "beautifulentropy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-26T19:59:52Z",
      "updatedAt": "2022-08-29T20:35:01Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "e521a7a006b9bc34d166781d8db64508f8ad07df",
      "headRepository": "beautifulentropy/draft-acme-ari",
      "headRefName": "patch-1",
      "headRefOid": "a6c78bc8c6fdffdeb4dfc52c4e0152134402aac9",
      "closedAt": "2022-08-29T20:35:01Z",
      "mergedAt": "2022-08-29T20:35:01Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "084928352dee06bb7787eec20b8da3be99ca4ddc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5A7b60",
          "commit": {
            "abbreviatedOid": "a6c78bc"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-29T20:34:48Z",
          "updatedAt": "2022-08-29T20:34:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOGGBRNc4-h4k9",
      "title": "Adding A.2. to heading",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/37",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-07T18:02:10Z",
      "updatedAt": "2022-09-09T17:46:51Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "084928352dee06bb7787eec20b8da3be99ca4ddc",
      "headRepository": "seanturner/draft-acme-ari",
      "headRefName": "patch-1",
      "headRefOid": "fce4a903d0a097ebec185fbb4795a5c70b90c2bb",
      "closedAt": "2022-09-09T17:46:51Z",
      "mergedAt": "2022-09-09T17:46:51Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "a99446534c8688d5a62f006a3b8c5b6a141a409e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5BudeO",
          "commit": {
            "abbreviatedOid": "fce4a90"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2022-09-09T17:46:12Z",
          "updatedAt": "2022-09-09T17:46:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOGGBRNc4-h5HD",
      "title": "Expand CA on 1st use",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/38",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-07T18:04:48Z",
      "updatedAt": "2022-09-09T17:48:51Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "084928352dee06bb7787eec20b8da3be99ca4ddc",
      "headRepository": "seanturner/draft-acme-ari",
      "headRefName": "patch-2",
      "headRefOid": "c73398eec78231041d0e727712edbac828496988",
      "closedAt": "2022-09-09T17:48:50Z",
      "mergedAt": "2022-09-09T17:48:50Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "a4cc6ea788d80d55544396df84575701d2d4ecff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5Buduo",
          "commit": {
            "abbreviatedOid": "c73398e"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T17:47:16Z",
          "updatedAt": "2022-09-09T17:47:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOGGBRNc4-iAiR",
      "title": "Wording Tweak",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/39",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Friendly suggestion for s1 2nd para.",
      "createdAt": "2022-09-07T18:32:58Z",
      "updatedAt": "2023-02-08T22:35:53Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "084928352dee06bb7787eec20b8da3be99ca4ddc",
      "headRepository": "seanturner/draft-acme-ari",
      "headRefName": "patch-3",
      "headRefOid": "f8d849bb2a73862b7eb1c8e9e489775bb27fd3e9",
      "closedAt": "2023-02-08T22:35:53Z",
      "mergedAt": "2023-02-08T22:35:53Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "1762a6f6d91b65717211ced91f1e2785aa6530b8"
      },
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Thanks for this! You're totally right that the phrasing here is awkward. I do agree with @robplee's comment improving the phrasing even further, so I'm going to approve+merge this PR, then iterate further in a follow-up. Thanks again!",
          "createdAt": "2023-02-08T22:35:17Z",
          "updatedAt": "2023-02-08T22:35:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5BlPuX",
          "commit": {
            "abbreviatedOid": "f8d849b"
          },
          "author": "robplee",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-08T08:07:50Z",
          "updatedAt": "2022-09-08T08:07:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I made a change around here in #29 to try to get rid of the phrase \"smearing of load\" as I feel \"distribution of load\" works a little better.  I'm not sure when it got reverted but it _could_ be changed again if it is felt that it's an improvement?\r\n\r\nWith regard to your changes, I'm not sure the start of the sentence works right now.  \"Issuing CA suggesting a period in which...\" doesn't flow nicely.  Perhaps \"Allowing Issuing CAs to suggest a period in which...\" works better?",
              "createdAt": "2022-09-08T08:07:50Z",
              "updatedAt": "2022-09-08T08:07:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5BoJ8u",
          "commit": {
            "abbreviatedOid": "f8d849b"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-08T16:26:43Z",
          "updatedAt": "2022-09-08T16:26:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It would. I actually had exactly that wording at one point in my head. I guess removing the two \"ings\" didn't work so well.",
              "createdAt": "2022-09-08T16:26:43Z",
              "updatedAt": "2022-09-08T16:26:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5M5WMd",
          "commit": {
            "abbreviatedOid": "f8d849b"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T22:35:29Z",
          "updatedAt": "2023-02-08T22:35:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOGGBRNc5TyWxF",
      "title": "Extend the ACME Order object with the ARI Payload",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/45",
      "state": "CLOSED",
      "author": "jvanasco",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "My idea for #42\r\n\r\n1.  Added a subsection \"### Extending ACME Order Objects with ARI\"\r\n2.  Added an \"Interoperability Considerations\" section.  I've seen this in a handful of specs over the years.  \r\n\r\nNotes:\r\n\r\n1. I just defined the fields with \"as defined in the aforementioned `renewalInfo` resource\"\r\n2. The only messy thing about this approach is we have \"Retry-After\" as a header on the resource URL, and it's migrated to a \"retryAfter\" field within the account object.  I don't like that, but I dislike even more the idea of making the \"Retry-After\" header a field in the resource URL.\r\n",
      "createdAt": "2023-06-23T21:37:09Z",
      "updatedAt": "2024-07-18T23:40:31Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "deb034b727523a28c43d3b2407339d17baf10e0e",
      "headRepository": "jvanasco/draft-acme-ari",
      "headRefName": "feature-acme_order_payload",
      "headRefOid": "974d435fe5b7101acfa57915a71e8de449ddfcb1",
      "closedAt": "2024-07-18T23:40:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "Now that I've merged https://github.com/aarongable/draft-acme-ari/pull/51, I think I'm much more amenable to including something like this in the next version. Want to update this to match the new layout (especially the IANA Considerations section)?",
          "createdAt": "2023-08-10T20:16:32Z",
          "updatedAt": "2023-08-10T20:16:32Z"
        },
        {
          "author": "jvanasco",
          "authorAssociation": "NONE",
          "body": "Sure. I'll try to get to it today or tomorrow.",
          "createdAt": "2023-08-10T20:27:14Z",
          "updatedAt": "2023-08-10T20:27:14Z"
        },
        {
          "author": "jvanasco",
          "authorAssociation": "NONE",
          "body": "Resubmitted via a force-push, as the other options were merge-commits or a new PR.\r\n\r\nNote: in two places (\"Interoperability Considerations\" and \"ACME Order Object Fields\"), `renewalInfo` was added above `replaces` for alphabetical ordering.\r\n",
          "createdAt": "2023-08-11T20:11:33Z",
          "updatedAt": "2023-08-11T20:11:33Z"
        },
        {
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "body": "At this point I no longer believe that this extension is necessary. It saves a grand total of one ARI query across the lifetime of the certificate, adds per-certificate information to the Order object (which causes issues with multi-cert-per-order extensions like ACME STAR), and co-mingles two different ACME resources inside a single object (which is done nowhere else in the protocol). As such I think I'm going to abandon this potential change. Thank you for the idea and work!",
          "createdAt": "2024-07-18T23:40:30Z",
          "updatedAt": "2024-07-18T23:40:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOGGBRNc5Xk7vJ",
      "title": "Improve IANA Considerations",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/48",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/aarongable/draft-acme-ari/issues/47",
      "createdAt": "2023-08-09T21:04:06Z",
      "updatedAt": "2023-08-09T22:32:23Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "523725141ef5178a906eb7ef8542e2dbaa73a7f9",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "iana-considerations",
      "headRefOid": "74546dde1aea2134a95a76336db2c719b95a1b66",
      "closedAt": "2023-08-09T22:32:22Z",
      "mergedAt": "2023-08-09T22:32:22Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "49f8100a727ed5dd9298e8f70df1cc9bc728fa86"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5dnqam",
          "commit": {
            "abbreviatedOid": "74546dd"
          },
          "author": "jcjones",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This seems to comport with the checklist in [Section 1.3 of RFC 8126](https://www.rfc-editor.org/rfc/rfc8126.html#section-1.3).",
          "createdAt": "2023-08-09T22:27:58Z",
          "updatedAt": "2023-08-09T22:27:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOGGBRNc5XlO-M",
      "title": "Simplify request certID construction",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/49",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Replaces the base64url-encoded OCSP CertID with a much simpler construction: the concatenation of the certificate's AKID and its Serial. Both of these values are available from the end-entity certificate itself, without needing access to the issuer cert. Additionally, this approach doesn't require any ability to serialize ASN.1 structures, and includes algorithm agility by virtue of placing the CA in control of the algorithm used in the AKID extension.\r\n\r\nFixes https://github.com/aarongable/draft-acme-ari/issues/43",
      "createdAt": "2023-08-09T22:12:43Z",
      "updatedAt": "2023-08-10T18:52:04Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "49f8100a727ed5dd9298e8f70df1cc9bc728fa86",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "simplify-request-format",
      "headRefOid": "b43c4f29f80d82782c54cd049eece9ad452efc4c",
      "closedAt": "2023-08-10T18:52:02Z",
      "mergedAt": "2023-08-10T18:52:02Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "d2f100814514b4d1ae3371e7887da3fa318e3f7f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5dn3Nv",
          "commit": {
            "abbreviatedOid": "b54419e"
          },
          "author": "jcjones",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-08-09T22:42:14Z",
          "updatedAt": "2023-08-09T22:42:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It's arguably clarified most by the example below, but since we generally want the text of an RFC to be unambiguous without resorting to decoding an example, but:\r\n\r\nReading this, I understand that the \"bytes of the the certificate's Authority Key Identifier extension value\" means the serialized bytes straight out of the certificate, which are defined as a `SEQUENCE` object with with tag, length, and inner values by RFC 5280. \r\n\r\nBy that token, one could imagine the Serial Number to be the _value_ of the Serial Number, which is an ASN.1 `INTEGER` with tag, length, and an inner value. Of course, then one could argue that if the RFC meant that, it would refer to the `CertificateSerialNumber` type out of 5280. And so forth, because ambiguity.\r\n\r\nThe AKI part is pretty clear, so maybe we append _field value_ to match the AKI's wording? **\"base64url-encoding of the bytes of the certificate's Serial Number field value.\"**\r\n\r\n```suggestion\r\nThe path component is computed by concatenating the base64url-encoding [@!RFC4648, section 5] of the bytes of the certificate's Authority Key Identifier (AKI) extension value, a literal period, and the base64url-encoding of the bytes of the certificate's Serial Number field value. All trailing \"`=`\" MUST be stripped from both parts of the path component. Thus the full request url is constructed as follows, where the \"`||`\" operator indicates string concatenation:\r\n```",
              "createdAt": "2023-08-09T22:42:14Z",
              "updatedAt": "2023-08-09T22:42:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5dn8XT",
          "commit": {
            "abbreviatedOid": "b54419e"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T23:11:16Z",
          "updatedAt": "2023-08-09T23:11:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yep, totally agreed. I had the same thoughts about the ambiguity of specifying which bytes from the AKI to use, and liked the \"field value\" phrasing I landed on there. Didn't even occur to me to do the same for the Serial, but I think you're absolutely right.",
              "createdAt": "2023-08-09T23:11:16Z",
              "updatedAt": "2023-08-09T23:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5duPDM",
          "commit": {
            "abbreviatedOid": "23c5ba2"
          },
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me. I've included a procedural version as an alternative. I personally find RFCs which use this format to be a bit more readable.",
          "createdAt": "2023-08-10T17:30:43Z",
          "updatedAt": "2023-08-10T17:31:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I took a stab at a more procedure driven definition. Feel free to take or leave this:\r\n\r\n```suggestion\r\nTo construct the path component, adhere to the following procedure:\r\n\r\n1. Retrieve the byte representation of the leaf certificate's Authority Key Identifier (AKI) extension value. Encode this using base64url, as detailed in [@!RFC4648, section 5].\r\n2. Similarly, retrieve and base64url encode the byte representation of the leaf certificate's Serial Number field value.\r\n3. Strip all trailing \"`=`\" characters from both the encoded AKI and Serial Number values.\r\n4. Concatenate the two encoded values using a period (`.`) separator.\r\n\r\nThe resulting request URL is assembled by appending this path component to the `renewalInfo URL`:\r\n\r\n~~~ text\r\n   request_url = {renewalInfo URL} || '/' || base64url(AKI) || '.' || base64url(Serial)\r\n~~~\r\n\r\nDefinitions:\r\n- `{renewalInfo URL}`: The base URL of the renewalInfo endpoint.\r\n- `base64url(AKI)`: The base64url encoded AKI value, with all trailing \"`=`\" characters stripped.\r\n- `base64url(Serial)`: The base64url encoded Serial Number, with all trailing \"`=`\" characters stripped.\r\n\r\nNote: Within the expression above, \"||\" symbolizes string concatenation.\r\n```",
              "createdAt": "2023-08-10T17:30:43Z",
              "updatedAt": "2023-08-10T17:31:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5duvpe",
          "commit": {
            "abbreviatedOid": "23c5ba2"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-10T18:48:04Z",
          "updatedAt": "2023-08-10T18:48:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I fear that this construction-based style is _too_ prescriptive -- what if the client gets the serial from elsewhere (e.g. it's own persistent state file, rather than the cert itself)? I think I've hit the best of both worlds by leaving the normative text mostly the same, but making the example much more procedural like this.",
              "createdAt": "2023-08-10T18:48:04Z",
              "updatedAt": "2023-08-10T18:48:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOGGBRNc5XlcAl",
      "title": "Replace ARI POST with a new Order object field",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/51",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Remove the specification of POSTing to the renewalInfo URL to indicate that a certificate has been replaced. Instead, include that information directly in New Order requests. This allows clients to communicate replacement information without having to make additional requests, and allows servers to act on that information at issuance time (e.g. allowing new orders during ARI suggested windows to bypass rate limits).\r\n\r\n~~DO NOT MERGE before https://github.com/aarongable/draft-acme-ari/pull/49~~\r\nFixes https://github.com/aarongable/draft-acme-ari/issues/50\r\nFixes https://github.com/aarongable/draft-acme-ari/issues/25",
      "createdAt": "2023-08-09T23:03:41Z",
      "updatedAt": "2023-08-10T20:13:25Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "d2f100814514b4d1ae3371e7887da3fa318e3f7f",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "replace-POST",
      "headRefOid": "52527107aa7b74b40e790c6f83909229e2446fab",
      "closedAt": "2023-08-10T20:13:24Z",
      "mergedAt": "2023-08-10T20:13:24Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "66ffbdc5899e1b39defbf1a2eb8c360cef0a7e7f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc5duzi8",
          "commit": {
            "abbreviatedOid": "096e5dc"
          },
          "author": "jcjones",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-10T18:59:22Z",
          "updatedAt": "2023-08-10T18:59:22Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "If a server rejects a New Order request because of the` replaces` field:\r\nA) What should a client do?\r\nB) How can one tell that this was the cause in the first place?\r\n\r\nShould I, as a client author, upon an error case for the New Order retry it without the `replaces` field? ",
              "createdAt": "2023-08-10T18:59:22Z",
              "updatedAt": "2023-08-10T18:59:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5du4kj",
          "commit": {
            "abbreviatedOid": "096e5dc"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-10T19:12:00Z",
          "updatedAt": "2023-08-10T19:12:01Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Maybe something like \"the Server SHOULD NOT reject [such requests] unless it would reject it for other reasons, but MAY choose to ignore the `replaces` field in such cases\"?",
              "createdAt": "2023-08-10T19:12:01Z",
              "updatedAt": "2023-08-10T19:12:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5du5OK",
          "commit": {
            "abbreviatedOid": "096e5dc"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-10T19:13:42Z",
          "updatedAt": "2023-08-10T19:13:43Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Or I guess just the simpler:\r\n> Servers **SHOULD** check that the identified certificate and the current New Order request correspond to the same ACME Account and share a preponderance of identifiers, and that the identified certificate has not already been marked as replaced by a different finalized Order. Servers **MAY** ignore the `replaces` field in requests which do not pass such checks.",
              "createdAt": "2023-08-10T19:13:42Z",
              "updatedAt": "2023-08-10T19:13:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGGBRNc5dvNZz",
          "commit": {
            "abbreviatedOid": "5252710"
          },
          "author": "beautifulentropy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Excellent, this reads quite nicely.",
          "createdAt": "2023-08-10T20:11:59Z",
          "updatedAt": "2023-08-10T20:11:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOGGBRNc5magq7",
      "title": "Clarify computation of base64(serial), provide better example",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/53",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Clarify that the serial portion of the unique identifier must be computed as the base64 of the DER encoding of the serial number, as otherwise the serial number is just an integer which could have multiple representations and therefore multiple potential base64 encodings.\r\n\r\nChange the example certificate to one which has a serial number that would be negative if not for the leading zero byte in the DER encoding, to demonstrate the importance of this specification.\r\n\r\nFixes https://github.com/aarongable/draft-acme-ari/issues/52",
      "createdAt": "2024-02-08T18:59:22Z",
      "updatedAt": "2024-02-08T19:01:15Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "6787edcad007543a7201fad7bf28171c3f0388b1",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "clarify-serial-encoding",
      "headRefOid": "84e80b0dae13b924b84987888dc450cf4d27e960",
      "closedAt": "2024-02-08T19:01:14Z",
      "mergedAt": "2024-02-08T19:01:14Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "63a4b9f94dbce8b3af039351dc3fa28deeb06eae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOGGBRNc5mbHqe",
      "title": "Add acknowledgements",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/54",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-08T20:53:07Z",
      "updatedAt": "2024-02-08T20:53:17Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "63a4b9f94dbce8b3af039351dc3fa28deeb06eae",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "ack",
      "headRefOid": "34ca55d339324beafe35ccf6c79230cbfebadf41",
      "closedAt": "2024-02-08T20:53:17Z",
      "mergedAt": "2024-02-08T20:53:17Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "4b680db73fbcc4ee393dbbd64ace8c217b093a5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOGGBRNc5pzTQK",
      "title": "Give broad definition of \"renewal\" at top of doc",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/62",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/aarongable/draft-acme-ari/issues/58",
      "createdAt": "2024-03-15T21:53:36Z",
      "updatedAt": "2024-03-15T21:54:48Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "6ab0f6122035896cffe3fe274f5b957951d56b42",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "define-renewal",
      "headRefOid": "b1c42627bac243cc9eef5e676d564c27b95633f3",
      "closedAt": "2024-03-15T21:54:47Z",
      "mergedAt": "2024-03-15T21:54:47Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "7da7e5b536428e1e3112b91469e095cba3e889ff"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOGGBRNc5pzUSK",
      "title": "Mention RFC5280 profile at top of doc",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/63",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/aarongable/draft-acme-ari/issues/59",
      "createdAt": "2024-03-15T21:57:11Z",
      "updatedAt": "2024-03-15T22:01:11Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "7da7e5b536428e1e3112b91469e095cba3e889ff",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "profile-5280",
      "headRefOid": "924684119f2550ba2c038047830133a35fd8bd51",
      "closedAt": "2024-03-15T22:01:10Z",
      "mergedAt": "2024-03-15T22:01:10Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "57bdbebc53c77006f19e7ade9e9e00f0be1a32b5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 64,
      "id": "PR_kwDOGGBRNc5pzaoi",
      "title": "Improve language re: \"replaces\" field processing",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/64",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/aarongable/draft-acme-ari/issues/57\r\nFixes https://github.com/aarongable/draft-acme-ari/issues/61",
      "createdAt": "2024-03-15T22:22:38Z",
      "updatedAt": "2024-03-15T22:25:14Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "57bdbebc53c77006f19e7ade9e9e00f0be1a32b5",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "replaces-identifiers",
      "headRefOid": "90216cff066ae164b54014a794fdcc68dd0b7862",
      "closedAt": "2024-03-15T22:25:13Z",
      "mergedAt": "2024-03-15T22:25:13Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "4e270f35a677f90db3ee4b11357150b0672cad1d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 67,
      "id": "PR_kwDOGGBRNc5sOdUZ",
      "title": "Need empty line before bullet list items.",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/67",
      "state": "MERGED",
      "author": "robstradling",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-10T10:03:05Z",
      "updatedAt": "2024-05-17T00:18:07Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "4b41d813ee77ce87851745b37002dad6f1068594",
      "headRepository": "robstradling/draft-acme-ari",
      "headRefName": "fix_bulleted_list",
      "headRefOid": "eea19dedc6dcdcd5097311aa2ecfe5a19b689773",
      "closedAt": "2024-04-10T21:59:27Z",
      "mergedAt": "2024-04-10T21:59:27Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "4f023a370e4bda51852b2780d22f7d80b96783fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGGBRNc52xvg4",
          "commit": {
            "abbreviatedOid": "eea19de"
          },
          "author": "aarongable",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-10T21:59:18Z",
          "updatedAt": "2024-04-10T21:59:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOGGBRNc5sS5EC",
      "title": "Remove \"finalized\" as an Order state",
      "url": "https://github.com/aarongable/draft-acme-ari/pull/68",
      "state": "MERGED",
      "author": "aarongable",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/aarongable/draft-acme-ari/issues/66",
      "createdAt": "2024-04-10T22:02:51Z",
      "updatedAt": "2024-04-11T15:01:28Z",
      "baseRepository": "aarongable/draft-acme-ari",
      "baseRefName": "main",
      "baseRefOid": "4f023a370e4bda51852b2780d22f7d80b96783fe",
      "headRepository": "aarongable/draft-acme-ari",
      "headRefName": "not-finalized",
      "headRefOid": "2970366ed8ff2baf223ebe26592af09cff8d7a8c",
      "closedAt": "2024-04-11T15:01:27Z",
      "mergedAt": "2024-04-11T15:01:27Z",
      "mergedBy": "aarongable",
      "mergeCommit": {
        "oid": "98cf320e72f3f5163f63c956ec26ed4c1ce59de0"
      },
      "comments": [
        {
          "author": "robstradling",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM!",
          "createdAt": "2024-04-11T10:26:19Z",
          "updatedAt": "2024-04-11T10:26:19Z"
        }
      ],
      "reviews": []
    }
  ]
}